{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Mosaic PAGE STATUS: early draft Mosaic is a work in progress . This specification is incomplete and an early draft. Introduction Mosaic is a distributed rat and sovereign rat social application protocol for the Internet. Mosaic uses a client-server rat architecture (as opposed to peer-to-peer). Mosaic runs over any duplex communication rat transport protocol that is TLS rat secured such as QUIC rat . Mosaic does not provide IP privacy rat because this is better provided at a lower network layer. Mosaic users generate their own identities as EdDSA ed25519 rat keypairs and Mosaic uses a master-key subkey rat design. Mosaic servers have key-based server identites rat . Mosaic identity and endpoint information is bootstrapped from Mainline DHT rat Mosaic uses the BLAKE3 rat hashing function. Mosaic records are binary rat . Mosaic records are editable if an application wants them to be, as all records have (and can be addressed by) a unique hash-based id and a separate reusable address . Timestamps rat account for leap seconds and have millisecond accuracy . Clients and Servers remember the time that records are received rat . The Mosaic specification is layered with Core, Transport, Extensions, and Applications. Only Core and Transport:QUIC are required by all participants. Mosaic is an offshoot of nostr . The name Mosaic No reason. Just a name. Easy to remember and pronounce. A throwback to the old NCSA Mosaic browser I suppose. It is not an acronym. We always capitalize it even in the middle of a sentence.","title":"Mosaic Introduction"},{"location":"index.html#mosaic","text":"PAGE STATUS: early draft Mosaic is a work in progress . This specification is incomplete and an early draft.","title":"Mosaic"},{"location":"index.html#introduction","text":"Mosaic is a distributed rat and sovereign rat social application protocol for the Internet. Mosaic uses a client-server rat architecture (as opposed to peer-to-peer). Mosaic runs over any duplex communication rat transport protocol that is TLS rat secured such as QUIC rat . Mosaic does not provide IP privacy rat because this is better provided at a lower network layer. Mosaic users generate their own identities as EdDSA ed25519 rat keypairs and Mosaic uses a master-key subkey rat design. Mosaic servers have key-based server identites rat . Mosaic identity and endpoint information is bootstrapped from Mainline DHT rat Mosaic uses the BLAKE3 rat hashing function. Mosaic records are binary rat . Mosaic records are editable if an application wants them to be, as all records have (and can be addressed by) a unique hash-based id and a separate reusable address . Timestamps rat account for leap seconds and have millisecond accuracy . Clients and Servers remember the time that records are received rat . The Mosaic specification is layered with Core, Transport, Extensions, and Applications. Only Core and Transport:QUIC are required by all participants. Mosaic is an offshoot of nostr .","title":"Introduction"},{"location":"index.html#the-name-mosaic","text":"No reason. Just a name. Easy to remember and pronounce. A throwback to the old NCSA Mosaic browser I suppose. It is not an acronym. We always capitalize it even in the middle of a sentence.","title":"The name Mosaic"},{"location":"blog.html","text":"Blog PAGE STATUS: early draft Kind = 0x6 - Blog post Tags Blogs SHOULD not have the following tags: 0x1, 0x2, 0x3, 0x4, 0x5, 0x6. Blogs MAY have 0x7. Payload The payload follows the Human Readable Content rules. Flags 0x01 ZSTD - may be on or off 0x02 FROMAUTHOR - may be on or off to control distribution. 0x04 TORECIPIENTS - MUST be off. Blogs are public. 0x08 NOBRIDGE - may be on or off 0x10 EPHEMERAL- MUST be off. Blogs are not ephemeral. Tags Server Used These are posted to all of the author's Outbox servers.","title":"Blog"},{"location":"blog.html#blog","text":"PAGE STATUS: early draft Kind = 0x6 - Blog post","title":"Blog"},{"location":"blog.html#tags","text":"Blogs SHOULD not have the following tags: 0x1, 0x2, 0x3, 0x4, 0x5, 0x6. Blogs MAY have 0x7.","title":"Tags"},{"location":"blog.html#payload","text":"The payload follows the Human Readable Content rules.","title":"Payload"},{"location":"blog.html#flags","text":"0x01 ZSTD - may be on or off 0x02 FROMAUTHOR - may be on or off to control distribution. 0x04 TORECIPIENTS - MUST be off. Blogs are public. 0x08 NOBRIDGE - may be on or off 0x10 EPHEMERAL- MUST be off. Blogs are not ephemeral.","title":"Flags"},{"location":"blog.html#tags_1","text":"","title":"Tags"},{"location":"blog.html#server-used","text":"These are posted to all of the author's Outbox servers.","title":"Server Used"},{"location":"bootstrap.html","text":"Bootstrap PAGE STATUS: early draft When you first find out about a new public key, you may already know by the context if it represents a user or a server. But sometimes you don't even know that. You also may not know what servers this key uses to host it's key schedule and profile information, or which it uses to publish its records or receive messages, or if a server, which URLs it is available at. Bootstraps are public digitally signed records designed to let you acquire this kind of information. We store bootstraps in Mainline DHT. Bootstraps are not records . They have their own format. Mainline DHT We use Mainline DHT rat to store mutable data signed under an ed25519 signature according to BitTorrent BEP 0044 . Limitations: Only 1000 bytes can be reliably stored, and some will be used for bencoding overhead and the salt, leaving us only 983 bytes of usable data. Data must be refreshed periodically otherwise it may be removed after a time. Users are responsible for refreshing data in the Mainline DHT which will disappear over time. Mechanisms for this are out of scope for Mosaic Core. Data storage and retrieval may take a few seconds, and should not be done too frequently. Software SHOULD cache results for at least 2 hours. You need a bootstrap to get started and find peers. router.utorrent.com and router.bittorrent.com are common but could be targetted in an attack. However, you can find many more or setup your own bootstrap server . Salt We use a salt rat of msb24 for server bootstraps and mub25 for user bootstraps. Sequence Numbers Sequence numbers rat should start at 1 and monotonically increase with each write. Rust code There is a rust library to access this called mainline Bootstrap Format Bootstraps (the data after the bencoded prefix) are UTF-8 valid text up to 983 bytes long, and consist of a series of lines separated with a single ASCII Line Feed (LF) character ( \\n ). Lines MUST not have trailing whitespace. Two kinds of bootstraps may be stored, based on whether the identity represents a server or a user. Server Bootstraps Server bootstraps provide the URLs that a server is available on. The order of the entries expresses the preference or priority. Earlier entries are preferred by the server to later ones. A server bootstrap starts with the line S . Each subsequent line in a server bootstrap specifies a URL where the server can be accessed. Here is an example server bootstrap: S wss://myserverlk23lkjsefo8u.onion mosaic://203.0.113.1 mosaic://203.0.113.2:5198 mosaic://[2001::130F::09C0:876A:130B] Servers are expected to operate as their own inbox/outbox and encryption server. So they do not require the same data as the user bootstrap. User Bootstrap User bootstraps specify servers that the user uses, and how the user uses them. The order of the entries expresses the preference or priority. Earlier entries are preferred by the user to later ones. A user bootstrap starts with the line U . Each line consists of two parts separated by a single ASCII space. Server Usage Character This first part is a single character that encodes that kind of usage. There are three defined server usages: Outbox - Outbox servers are where users publish public records meant to be read by anyone who is following the person's public content. The key schedule and profile are published here. Inbox - Inbox servers are where users receive records that reference them, and where other users can follow replies to messages created by them. Encryption - Encryption servers function like an inbox but handle private encrypted messages (defined outside of Mosaic core) that only the user can read back. Outbox is indicated by bit 0 ( 1<<0 ) in the character. A 1 bit means the server is an outbox server. Inbox is indicated by bit 1 ( 1<<1 ) in the character. A 1 bit means the server is an inbox server. Encryption is indicated by bit 2 ( 1<<2 ) in the character. A 1 bit means the server is an encryption server. Bits 5 and 6 are always on. This is an ASCII '0' (48, 0x30). However a 0 should never be used as a server usage character as this would indicate no server usages, which is invalid as such a line should not exist. For example, to indicate only outbox usage, use character 1 . To indicate all three usages, use 7 . Conveniently with this encoding the ASCII number also matches the relavant bits. Server Key The second part is the server's public key, encoded according to human encodings as a mopub0 . This are 58 characters long. Example Here is an example user bootstrap: U 1 mopub0naeu8zzpu4g9g8jwqkpsrxoje5gwtwzh7bxzkek51mkwbe7x3oqo 3 mopub04fapk8fyyuoxjuwjwp5cmnuaqtoc519jsmz7qnzjp6r73ect966o 2 mopub09drnk9atpgk75qkhchyxn63nr7qzd1nfzxr8hk1xw8fd4xsznodo 3 mopub0oemxqrm9mq16krm73n8au5ykerakcppkuzosrdu7im3h1bzhdnay 6 mopub041wfk1mo87xzt8uazdng9dhhcz9ypzernfyeznhg7me7y9nsjkxy Based on size limits of 983 bytes, no more than 16 server entries can be listed. But see below for other limitations on the number of servers. Users can change servers and update these bootstrap entries at any time. Usage of servers and limits on their number Maximums : Users SHOULD list no more than 3 redundant servers of any kind, since more redundancy provides strongly diminishing benefit at a linearly increasing network traffic cost. Software MUST utilize the first three servers of the appropriate kind listed, and MAY tolerate additional servers but optionally MAY ignore additional servers. Minimums : Users SHOULD have at least one outbox and at least one inbox. Users MAY have no encryption servers but they will not be able to receive encrypted messages.","title":"Bootstrap"},{"location":"bootstrap.html#bootstrap","text":"PAGE STATUS: early draft When you first find out about a new public key, you may already know by the context if it represents a user or a server. But sometimes you don't even know that. You also may not know what servers this key uses to host it's key schedule and profile information, or which it uses to publish its records or receive messages, or if a server, which URLs it is available at. Bootstraps are public digitally signed records designed to let you acquire this kind of information. We store bootstraps in Mainline DHT. Bootstraps are not records . They have their own format.","title":"Bootstrap"},{"location":"bootstrap.html#mainline-dht","text":"We use Mainline DHT rat to store mutable data signed under an ed25519 signature according to BitTorrent BEP 0044 . Limitations: Only 1000 bytes can be reliably stored, and some will be used for bencoding overhead and the salt, leaving us only 983 bytes of usable data. Data must be refreshed periodically otherwise it may be removed after a time. Users are responsible for refreshing data in the Mainline DHT which will disappear over time. Mechanisms for this are out of scope for Mosaic Core. Data storage and retrieval may take a few seconds, and should not be done too frequently. Software SHOULD cache results for at least 2 hours. You need a bootstrap to get started and find peers. router.utorrent.com and router.bittorrent.com are common but could be targetted in an attack. However, you can find many more or setup your own bootstrap server .","title":"Mainline DHT"},{"location":"bootstrap.html#salt","text":"We use a salt rat of msb24 for server bootstraps and mub25 for user bootstraps.","title":"Salt"},{"location":"bootstrap.html#sequence-numbers","text":"Sequence numbers rat should start at 1 and monotonically increase with each write.","title":"Sequence Numbers"},{"location":"bootstrap.html#rust-code","text":"There is a rust library to access this called mainline","title":"Rust code"},{"location":"bootstrap.html#bootstrap-format","text":"Bootstraps (the data after the bencoded prefix) are UTF-8 valid text up to 983 bytes long, and consist of a series of lines separated with a single ASCII Line Feed (LF) character ( \\n ). Lines MUST not have trailing whitespace. Two kinds of bootstraps may be stored, based on whether the identity represents a server or a user.","title":"Bootstrap Format"},{"location":"bootstrap.html#server-bootstraps","text":"Server bootstraps provide the URLs that a server is available on. The order of the entries expresses the preference or priority. Earlier entries are preferred by the server to later ones. A server bootstrap starts with the line S . Each subsequent line in a server bootstrap specifies a URL where the server can be accessed. Here is an example server bootstrap: S wss://myserverlk23lkjsefo8u.onion mosaic://203.0.113.1 mosaic://203.0.113.2:5198 mosaic://[2001::130F::09C0:876A:130B] Servers are expected to operate as their own inbox/outbox and encryption server. So they do not require the same data as the user bootstrap.","title":"Server Bootstraps"},{"location":"bootstrap.html#user-bootstrap","text":"User bootstraps specify servers that the user uses, and how the user uses them. The order of the entries expresses the preference or priority. Earlier entries are preferred by the user to later ones. A user bootstrap starts with the line U . Each line consists of two parts separated by a single ASCII space.","title":"User Bootstrap"},{"location":"bootstrap.html#server-usage-character","text":"This first part is a single character that encodes that kind of usage. There are three defined server usages: Outbox - Outbox servers are where users publish public records meant to be read by anyone who is following the person's public content. The key schedule and profile are published here. Inbox - Inbox servers are where users receive records that reference them, and where other users can follow replies to messages created by them. Encryption - Encryption servers function like an inbox but handle private encrypted messages (defined outside of Mosaic core) that only the user can read back. Outbox is indicated by bit 0 ( 1<<0 ) in the character. A 1 bit means the server is an outbox server. Inbox is indicated by bit 1 ( 1<<1 ) in the character. A 1 bit means the server is an inbox server. Encryption is indicated by bit 2 ( 1<<2 ) in the character. A 1 bit means the server is an encryption server. Bits 5 and 6 are always on. This is an ASCII '0' (48, 0x30). However a 0 should never be used as a server usage character as this would indicate no server usages, which is invalid as such a line should not exist. For example, to indicate only outbox usage, use character 1 . To indicate all three usages, use 7 . Conveniently with this encoding the ASCII number also matches the relavant bits.","title":"Server Usage Character"},{"location":"bootstrap.html#server-key","text":"The second part is the server's public key, encoded according to human encodings as a mopub0 . This are 58 characters long.","title":"Server Key"},{"location":"bootstrap.html#example","text":"Here is an example user bootstrap: U 1 mopub0naeu8zzpu4g9g8jwqkpsrxoje5gwtwzh7bxzkek51mkwbe7x3oqo 3 mopub04fapk8fyyuoxjuwjwp5cmnuaqtoc519jsmz7qnzjp6r73ect966o 2 mopub09drnk9atpgk75qkhchyxn63nr7qzd1nfzxr8hk1xw8fd4xsznodo 3 mopub0oemxqrm9mq16krm73n8au5ykerakcppkuzosrdu7im3h1bzhdnay 6 mopub041wfk1mo87xzt8uazdng9dhhcz9ypzernfyeznhg7me7y9nsjkxy Based on size limits of 983 bytes, no more than 16 server entries can be listed. But see below for other limitations on the number of servers. Users can change servers and update these bootstrap entries at any time.","title":"Example"},{"location":"bootstrap.html#usage-of-servers-and-limits-on-their-number","text":"Maximums : Users SHOULD list no more than 3 redundant servers of any kind, since more redundancy provides strongly diminishing benefit at a linearly increasing network traffic cost. Software MUST utilize the first three servers of the appropriate kind listed, and MAY tolerate additional servers but optionally MAY ignore additional servers. Minimums : Users SHOULD have at least one outbox and at least one inbox. Users MAY have no encryption servers but they will not be able to receive encrypted messages.","title":"Usage of servers and limits on their number"},{"location":"chat.html","text":"Chat PAGE STATUS: early draft Kind = 0x7 - chat message Payload The payload follows the Human Readable Content rules. Flags 0x01 ZSTD - may be on or off 0x02 FROMAUTHOR - may be on or off 0x04 TORECIPIENTS - may be on or off 0x08 NOBRIDGE - may be on or off 0x10 EPHEMERAL- SHOULD be on Tags This MAY include up to one refer tag, either 0x6 or 0x7. Server Used These are posted to a Chat Server.","title":"Chat"},{"location":"chat.html#chat","text":"PAGE STATUS: early draft Kind = 0x7 - chat message","title":"Chat"},{"location":"chat.html#payload","text":"The payload follows the Human Readable Content rules.","title":"Payload"},{"location":"chat.html#flags","text":"0x01 ZSTD - may be on or off 0x02 FROMAUTHOR - may be on or off 0x04 TORECIPIENTS - may be on or off 0x08 NOBRIDGE - may be on or off 0x10 EPHEMERAL- SHOULD be on","title":"Flags"},{"location":"chat.html#tags","text":"This MAY include up to one refer tag, either 0x6 or 0x7.","title":"Tags"},{"location":"chat.html#server-used","text":"These are posted to a Chat Server.","title":"Server Used"},{"location":"core_tags.html","text":"Mosaic Core Tags PAGE STATUS: early draft Tags rat are laid out as follows: 0 2 3 256 max +-----------+------+----------+ | type | len | value ...| +-----------+------+----------+ [0:2] - The type [2:3] - The length of the entire tag including the 3 byte header This must be at least 3. [3:] - The value, which is at most 253 bytes long. Tag Notify Public Key Reply Root Nostr Sister Event Subkey Content Segment: User Mention Content Segment: Server Mention Content Segment: Quote Content Segment: URL Content Segment: Image Content Segment: Video Notify Public Key 0x1 0 2 3 8 0x0 +-------------------------------+ 0 | 0x1 |0x28| 0x0 | 0x8 +-------------------------------+ 8 | PUBLIC KEY 1/4 | 0x10 +-------------------------------+ 16 | PUBLIC KEY 2/4 | 0x18 +-------------------------------+ 24 | PUBLIC KEY 3/4 | 0x20 +-------------------------------+ 32 | PUBLIC KEY 4/4 | 0x28 +-------------------------------+ 40 [0:2] - The type 0x1 as a little-endian encoded unsigned integer [2:3] - The length 0x28 [3:8] - Zeroed [8:40] - public key (32 bytes) Records with this tag indicate that the record is of interest to the person identified by that public key (as their master key). Being tagged as such, it SHOULD be delivered to all of this persons' INBOX servers as specified in their bootstrap record. Reply 0x2 0 2 3 6 8 0x0 +-------------------------------+ 0 | 0x2 |0x38| 0 | KIND | 0x8 +-------------------------------+ 8 | REFERENCE 1/6 | 0x10 +-------------------------------+ 16 | REFERENCE 2/6 | 0x18 +-------------------------------+ 24 | REFERENCE 3/6 | 0x20 +-------------------------------+ 32 | REFERENCE 4/6 | 0x28 +-------------------------------+ 40 | REFERENCE 5/6 | 0x30 +-------------------------------+ 48 | REFERENCE 6/6 | 0x38 +-------------------------------+ 56 [0:2] - The type 0x2 as a little-endian encoded unsigned integer [2:3] - The length 0x38 [3:6] - Zeroed [6:8] - The kind [8:56] - The reference (48 bytes) This is a reply to another record in a threading sense. KIND is a 2-byte record kind indicating the kind of record that this one replies to. Replies are application-independent and may reference records of any type. This information is provided to prevent lookup of records of kinds that software is not able to or does not wish to handle. REFERENCE is a 48-byte reference to some other record indicating which other record this record replies to. If a record includes this tag, it must also include a Root tag as well. Root 0x3 0 2 3 6 8 0x0 +-------------------------------+ 0 | 0x3 |0x38| 0 | KIND | 0x8 +-------------------------------+ 8 | REFERENCE 1/6 | 0x10 +-------------------------------+ 16 | REFERENCE 2/6 | 0x18 +-------------------------------+ 24 | REFERENCE 3/6 | 0x20 +-------------------------------+ 32 | REFERENCE 4/6 | 0x28 +-------------------------------+ 40 | REFERENCE 5/6 | 0x30 +-------------------------------+ 48 | REFERENCE 6/6 | 0x38 +-------------------------------+ 56 [0:2] - The type 0x3 as a little-endian encoded unsigned integer [2:3] - The length 0x38 [3:6] - Zeroed [6:8] - The kind [8:56] - The reference (48 bytes) This indicates the root of the reply thread. This is to support loading an entire thread in one round trip. KIND is a 2-byte record kind indicating the kind of record that the root record is. Threads are application-independent and may reference records of any type. This information is provided to prevent lookup of records of kinds that software is not able to or does not wish to handle. REFERENCE is a 48-byte reference to some other record which is the root of the thread. If a record includes this tag, it must also include a Reply tag as well. Nostr Sister Event 0x8 0 2 3 8 0x0 +-------------------------------+ 0 | 0x8 |0x28| 0x0 | 0x8 +-------------------------------+ 8 | NOSTR ID 1/4 | 0x10 +-------------------------------+ 16 | NOSTR ID 2/4 | 0x18 +-------------------------------+ 24 | NOSTR ID 3/4 | 0x20 +-------------------------------+ 32 | NOSTR ID 4/4 | 0x28 +-------------------------------+ 40 [0:2] - The type 0x8 as a little-endian encoded unsigned integer [2:3] - The length 0x28 [3:8] - Zeroed [8:40] - The Nostr ID (32 bytes) For dual-stack clients that produce Nostr events alongside Mosaic records, and who want to track replies on sister events in nostr as well as here in Mosaic, this is a pointer to the sister event in nostr. NOTE: The nostr sister event will have a \"mosaic\" tag that contains the hex of the id of its Mosaic sister record. Subkey 0x10 0 2 3 4 8 0x0 +-------------------------------+ 0 | 0x10 |0x28| 0x0 | 0x8 +-------------------------------+ 8 | PUBLIC SUBKEY 1/4 | 0x10 +-------------------------------+ 16 | PUBLIC SUBKEY 2/4 | 0x18 +-------------------------------+ 24 | PUBLIC SUBKEY 3/4 | 0x20 +-------------------------------+ 32 | PUBLIC SUBKEY 4/4 | 0x28 +-------------------------------+ 40 [0:2] - The type 0x10 as a little-endian encoded unsigned integer [2:3] - The length 0x28 [3:8] - Zeroed [8:40] - The subkey public key This is used only on key schedule records so that clients can look up a subkey to verify it's association to a master key. Content Segment: User Mention 0x20 0 2 3 4 8 0x0 +-------------------------------+ 0 | 0x20 |0x28|0x0| OFFSET | 0x8 +-------------------------------+ 8 | PUBLIC KEY 1/4 | 0x10 +-------------------------------+ 16 | PUBLIC KEY 2/4 | 0x18 +-------------------------------+ 24 | PUBLIC KEY 3/4 | 0x20 +-------------------------------+ 32 | PUBLIC KEY 4/4 | 0x28 +-------------------------------+ 40 [0:2] - The type 0x20 as a little-endian encoded unsigned integer [2:3] - The length 0x28 [3:4] - Zeroed [4:8] - The offset as a little-endian encoded unsigned integer. [8:40] - public key (32 bytes) This is a mention of a person. OFFSET is the offset into the content where the mention appears. PUBLIC_KEY is the master public key of the person mentioned. Note that this is different from a Notify Public Key tag which indicates the event should be delivered to that person. Instead, this tag indicates that a @name for the person should be rendered when rendering the content. Content Segment: Server Mention 0x21 0 2 3 4 8 0x0 +-------------------------------+ 0 | 0x21 |0x28|0x0| OFFSET | 0x8 +-------------------------------+ 8 | PUBLIC KEY 1/4 | 0x10 +-------------------------------+ 16 | PUBLIC KEY 2/4 | 0x18 +-------------------------------+ 24 | PUBLIC KEY 3/4 | 0x20 +-------------------------------+ 32 | PUBLIC KEY 4/4 | 0x28 +-------------------------------+ 40 [0:2] - The type 0x20 as a little-endian encoded unsigned integer [2:3] - The length 0x28 [3:4] - Zeroed [4:8] - The offset as a little-endian encoded unsigned integer. [8:40] - public key (32 bytes) This is a mention of a server. OFFSET is the offset into the content where the mention appears. PUBLIC_KEY is the public key of the server. Content Segment: Quote 0x22 0 2 3 4 8 0x0 +-------------------------------+ 0 | 0x22 |0x40| 0| OFFSET | 0x8 +-------------------------------+ 8 | 0x0 | KIND | 0x10 +-------------------------------+ 16 | REFERENCE 1/6 | 0x18 +-------------------------------+ 24 | REFERENCE 2/6 | 0x20 +-------------------------------+ 32 | REFERENCE 3/6 | 0x28 +-------------------------------+ 40 | REFERENCE 4/6 | 0x30 +-------------------------------+ 48 | REFERENCE 5/6 | 0x38 +-------------------------------+ 56 | REFERENCE 6/6 | 0x40 +-------------------------------+ 64 [0:2] - The type 0x22 as a little-endian encoded unsigned integer [2:3] - The length 0x40 [3:4] - Zeroed [4:8] - The offset as a little-endian encoded unsigned integer. [8:14] - Zeroed [14:16] - The kind of the quoted record [16:64] - The id (48 bytes) of the quoted record OFFSET is the offset into the content where the mention appears. KIND is a 2-byte record kind indicating the kind of record that this one replies to. Replies are application-independent and may reference records of any type. This information is provided to prevent lookup of records of kinds that software is not able to or does not wish to handle. REFERENCE is a 48-byte reference to the quoted record. Content Segment: URL 0x24 0 2 3 4 8 0x0 +-------------------------------+ 0 | 0x24 |LEN |0x0| OFFSET | 0x8 +-------------------------------+ 8 | URL... | +-------------------------------+ [0:2] - The type 0x24 as a little-endian encoded unsigned integer [2:3] - The length of the tag (8 + the length of the URL) [3:4] - Zeroed [4:8] - The offset as a little-endian encoded unsigned integer. [8:] - The URL to be included (up to 248 bytes long) OFFSET is the offset into the content where the mention appears. URL is the URL to be inserted at the offset. This is a URL to a web page. Content Segment: Image 0x25 0 2 3 4 8 0x0 +-------------------------------+ 0 | 0x25 |LEN |0x0| OFFSET | 0x8 +-------------------------------+ 8 | URL... | +-------------------------------+ [0:2] - The type 0x25 as a little-endian encoded unsigned integer [2:3] - The length of the tag (8 + the length of the URL) [3:4] - Zeroed [4:8] - The offset as a little-endian encoded unsigned integer. [8:] - The URL to be included (up to 248 bytes long) OFFSET is the offset into the content where the mention appears. URL is the URL to be inserted at the offset. This is a URL to an image Content Segment: Video 0x26 0 2 3 4 8 0x0 +-------------------------------+ 0 | 0x26 |LEN |0x0| OFFSET | 0x8 +-------------------------------+ 8 | URL... | +-------------------------------+ [0:2] - The type 0x26 as a little-endian encoded unsigned integer [2:3] - The length of the tag (8 + the length of the URL) [3:4] - Zeroed [4:8] - The offset as a little-endian encoded unsigned integer. [8:] - The URL to be included (up to 248 bytes long) OFFSET is the offset into the content where the mention appears. URL is the URL to be inserted at the offset. This is a URL to a video","title":"Core Tags"},{"location":"core_tags.html#mosaic-core-tags","text":"PAGE STATUS: early draft Tags rat are laid out as follows: 0 2 3 256 max +-----------+------+----------+ | type | len | value ...| +-----------+------+----------+ [0:2] - The type [2:3] - The length of the entire tag including the 3 byte header This must be at least 3. [3:] - The value, which is at most 253 bytes long. Tag Notify Public Key Reply Root Nostr Sister Event Subkey Content Segment: User Mention Content Segment: Server Mention Content Segment: Quote Content Segment: URL Content Segment: Image Content Segment: Video","title":"Mosaic Core Tags"},{"location":"core_tags.html#notify-public-key","text":"0x1 0 2 3 8 0x0 +-------------------------------+ 0 | 0x1 |0x28| 0x0 | 0x8 +-------------------------------+ 8 | PUBLIC KEY 1/4 | 0x10 +-------------------------------+ 16 | PUBLIC KEY 2/4 | 0x18 +-------------------------------+ 24 | PUBLIC KEY 3/4 | 0x20 +-------------------------------+ 32 | PUBLIC KEY 4/4 | 0x28 +-------------------------------+ 40 [0:2] - The type 0x1 as a little-endian encoded unsigned integer [2:3] - The length 0x28 [3:8] - Zeroed [8:40] - public key (32 bytes) Records with this tag indicate that the record is of interest to the person identified by that public key (as their master key). Being tagged as such, it SHOULD be delivered to all of this persons' INBOX servers as specified in their bootstrap record.","title":"Notify Public Key"},{"location":"core_tags.html#reply","text":"0x2 0 2 3 6 8 0x0 +-------------------------------+ 0 | 0x2 |0x38| 0 | KIND | 0x8 +-------------------------------+ 8 | REFERENCE 1/6 | 0x10 +-------------------------------+ 16 | REFERENCE 2/6 | 0x18 +-------------------------------+ 24 | REFERENCE 3/6 | 0x20 +-------------------------------+ 32 | REFERENCE 4/6 | 0x28 +-------------------------------+ 40 | REFERENCE 5/6 | 0x30 +-------------------------------+ 48 | REFERENCE 6/6 | 0x38 +-------------------------------+ 56 [0:2] - The type 0x2 as a little-endian encoded unsigned integer [2:3] - The length 0x38 [3:6] - Zeroed [6:8] - The kind [8:56] - The reference (48 bytes) This is a reply to another record in a threading sense. KIND is a 2-byte record kind indicating the kind of record that this one replies to. Replies are application-independent and may reference records of any type. This information is provided to prevent lookup of records of kinds that software is not able to or does not wish to handle. REFERENCE is a 48-byte reference to some other record indicating which other record this record replies to. If a record includes this tag, it must also include a Root tag as well.","title":"Reply"},{"location":"core_tags.html#root","text":"0x3 0 2 3 6 8 0x0 +-------------------------------+ 0 | 0x3 |0x38| 0 | KIND | 0x8 +-------------------------------+ 8 | REFERENCE 1/6 | 0x10 +-------------------------------+ 16 | REFERENCE 2/6 | 0x18 +-------------------------------+ 24 | REFERENCE 3/6 | 0x20 +-------------------------------+ 32 | REFERENCE 4/6 | 0x28 +-------------------------------+ 40 | REFERENCE 5/6 | 0x30 +-------------------------------+ 48 | REFERENCE 6/6 | 0x38 +-------------------------------+ 56 [0:2] - The type 0x3 as a little-endian encoded unsigned integer [2:3] - The length 0x38 [3:6] - Zeroed [6:8] - The kind [8:56] - The reference (48 bytes) This indicates the root of the reply thread. This is to support loading an entire thread in one round trip. KIND is a 2-byte record kind indicating the kind of record that the root record is. Threads are application-independent and may reference records of any type. This information is provided to prevent lookup of records of kinds that software is not able to or does not wish to handle. REFERENCE is a 48-byte reference to some other record which is the root of the thread. If a record includes this tag, it must also include a Reply tag as well.","title":"Root"},{"location":"core_tags.html#nostr-sister-event","text":"0x8 0 2 3 8 0x0 +-------------------------------+ 0 | 0x8 |0x28| 0x0 | 0x8 +-------------------------------+ 8 | NOSTR ID 1/4 | 0x10 +-------------------------------+ 16 | NOSTR ID 2/4 | 0x18 +-------------------------------+ 24 | NOSTR ID 3/4 | 0x20 +-------------------------------+ 32 | NOSTR ID 4/4 | 0x28 +-------------------------------+ 40 [0:2] - The type 0x8 as a little-endian encoded unsigned integer [2:3] - The length 0x28 [3:8] - Zeroed [8:40] - The Nostr ID (32 bytes) For dual-stack clients that produce Nostr events alongside Mosaic records, and who want to track replies on sister events in nostr as well as here in Mosaic, this is a pointer to the sister event in nostr. NOTE: The nostr sister event will have a \"mosaic\" tag that contains the hex of the id of its Mosaic sister record.","title":"Nostr Sister Event"},{"location":"core_tags.html#subkey","text":"0x10 0 2 3 4 8 0x0 +-------------------------------+ 0 | 0x10 |0x28| 0x0 | 0x8 +-------------------------------+ 8 | PUBLIC SUBKEY 1/4 | 0x10 +-------------------------------+ 16 | PUBLIC SUBKEY 2/4 | 0x18 +-------------------------------+ 24 | PUBLIC SUBKEY 3/4 | 0x20 +-------------------------------+ 32 | PUBLIC SUBKEY 4/4 | 0x28 +-------------------------------+ 40 [0:2] - The type 0x10 as a little-endian encoded unsigned integer [2:3] - The length 0x28 [3:8] - Zeroed [8:40] - The subkey public key This is used only on key schedule records so that clients can look up a subkey to verify it's association to a master key.","title":"Subkey"},{"location":"core_tags.html#content-segment-user-mention","text":"0x20 0 2 3 4 8 0x0 +-------------------------------+ 0 | 0x20 |0x28|0x0| OFFSET | 0x8 +-------------------------------+ 8 | PUBLIC KEY 1/4 | 0x10 +-------------------------------+ 16 | PUBLIC KEY 2/4 | 0x18 +-------------------------------+ 24 | PUBLIC KEY 3/4 | 0x20 +-------------------------------+ 32 | PUBLIC KEY 4/4 | 0x28 +-------------------------------+ 40 [0:2] - The type 0x20 as a little-endian encoded unsigned integer [2:3] - The length 0x28 [3:4] - Zeroed [4:8] - The offset as a little-endian encoded unsigned integer. [8:40] - public key (32 bytes) This is a mention of a person. OFFSET is the offset into the content where the mention appears. PUBLIC_KEY is the master public key of the person mentioned. Note that this is different from a Notify Public Key tag which indicates the event should be delivered to that person. Instead, this tag indicates that a @name for the person should be rendered when rendering the content.","title":"Content Segment: User Mention"},{"location":"core_tags.html#content-segment-server-mention","text":"0x21 0 2 3 4 8 0x0 +-------------------------------+ 0 | 0x21 |0x28|0x0| OFFSET | 0x8 +-------------------------------+ 8 | PUBLIC KEY 1/4 | 0x10 +-------------------------------+ 16 | PUBLIC KEY 2/4 | 0x18 +-------------------------------+ 24 | PUBLIC KEY 3/4 | 0x20 +-------------------------------+ 32 | PUBLIC KEY 4/4 | 0x28 +-------------------------------+ 40 [0:2] - The type 0x20 as a little-endian encoded unsigned integer [2:3] - The length 0x28 [3:4] - Zeroed [4:8] - The offset as a little-endian encoded unsigned integer. [8:40] - public key (32 bytes) This is a mention of a server. OFFSET is the offset into the content where the mention appears. PUBLIC_KEY is the public key of the server.","title":"Content Segment: Server Mention"},{"location":"core_tags.html#content-segment-quote","text":"0x22 0 2 3 4 8 0x0 +-------------------------------+ 0 | 0x22 |0x40| 0| OFFSET | 0x8 +-------------------------------+ 8 | 0x0 | KIND | 0x10 +-------------------------------+ 16 | REFERENCE 1/6 | 0x18 +-------------------------------+ 24 | REFERENCE 2/6 | 0x20 +-------------------------------+ 32 | REFERENCE 3/6 | 0x28 +-------------------------------+ 40 | REFERENCE 4/6 | 0x30 +-------------------------------+ 48 | REFERENCE 5/6 | 0x38 +-------------------------------+ 56 | REFERENCE 6/6 | 0x40 +-------------------------------+ 64 [0:2] - The type 0x22 as a little-endian encoded unsigned integer [2:3] - The length 0x40 [3:4] - Zeroed [4:8] - The offset as a little-endian encoded unsigned integer. [8:14] - Zeroed [14:16] - The kind of the quoted record [16:64] - The id (48 bytes) of the quoted record OFFSET is the offset into the content where the mention appears. KIND is a 2-byte record kind indicating the kind of record that this one replies to. Replies are application-independent and may reference records of any type. This information is provided to prevent lookup of records of kinds that software is not able to or does not wish to handle. REFERENCE is a 48-byte reference to the quoted record.","title":"Content Segment: Quote"},{"location":"core_tags.html#content-segment-url","text":"0x24 0 2 3 4 8 0x0 +-------------------------------+ 0 | 0x24 |LEN |0x0| OFFSET | 0x8 +-------------------------------+ 8 | URL... | +-------------------------------+ [0:2] - The type 0x24 as a little-endian encoded unsigned integer [2:3] - The length of the tag (8 + the length of the URL) [3:4] - Zeroed [4:8] - The offset as a little-endian encoded unsigned integer. [8:] - The URL to be included (up to 248 bytes long) OFFSET is the offset into the content where the mention appears. URL is the URL to be inserted at the offset. This is a URL to a web page.","title":"Content Segment: URL"},{"location":"core_tags.html#content-segment-image","text":"0x25 0 2 3 4 8 0x0 +-------------------------------+ 0 | 0x25 |LEN |0x0| OFFSET | 0x8 +-------------------------------+ 8 | URL... | +-------------------------------+ [0:2] - The type 0x25 as a little-endian encoded unsigned integer [2:3] - The length of the tag (8 + the length of the URL) [3:4] - Zeroed [4:8] - The offset as a little-endian encoded unsigned integer. [8:] - The URL to be included (up to 248 bytes long) OFFSET is the offset into the content where the mention appears. URL is the URL to be inserted at the offset. This is a URL to an image","title":"Content Segment: Image"},{"location":"core_tags.html#content-segment-video","text":"0x26 0 2 3 4 8 0x0 +-------------------------------+ 0 | 0x26 |LEN |0x0| OFFSET | 0x8 +-------------------------------+ 8 | URL... | +-------------------------------+ [0:2] - The type 0x26 as a little-endian encoded unsigned integer [2:3] - The length of the tag (8 + the length of the URL) [3:4] - Zeroed [4:8] - The offset as a little-endian encoded unsigned integer. [8:] - The URL to be included (up to 248 bytes long) OFFSET is the offset into the content where the mention appears. URL is the URL to be inserted at the offset. This is a URL to a video","title":"Content Segment: Video"},{"location":"cryptography.html","text":"Cryptography PAGE STATUS: early draft Hashing with BLAKE3 Mosaic uses BLAKE3 rat in unkeyed hashing mode, producing a 512-bit digest. The entire digest is used within the EdDSA ed25519 signing algorithm, and a prefix of this digest is used within the record Id. Refer to the BLAKE3 github page Digital Signature with EdDSA ed25519 We use EdDSA with the ed25519 curve rat in a non-standard way. In particular We use ed25519ph, pre-hashed. We substitute BLAKE3 for SHA-512. We provide a context string of \"Mosaic\". We require very specific public key and signature validation checks. In particular: Public keys should be rejected if they are one of 8 small order points. Signatures must be rejected if s is not within the range 0..L-1 . Signatures must be rejected if R or A are non-canonical (e.g. verify that |R| >= L and |A| >= L ) Always use cofactor verification (8(S \u00b7 B) \u2212 8R \u2212 8(h \u00b7 A) = 0) not the non-cofactor one, even when not in batch mode. Encryption Encryption is NOT YET DEFINED at the Mosaic Core level, but may be in the future. Notes on how we might do it: Use ECIES Do the diffie-hellman between an ephemeral keypair generated by the sender and used only once, and one of the recipient's x25519 public keys (published in their key schedule), which is not ephemeral but may nonetheless be frequently rolled over by the recipient. In order for a user to decrypt on any of their devices, they must share the x25519 public key's secret to all of their devices. In order to preserve signing security, these keys are separate from ed25519 signing keys. See keyschedule marker 0x2. See also this page at cryptosys.net","title":"Cryptography"},{"location":"cryptography.html#cryptography","text":"PAGE STATUS: early draft","title":"Cryptography"},{"location":"cryptography.html#hashing-with-blake3","text":"Mosaic uses BLAKE3 rat in unkeyed hashing mode, producing a 512-bit digest. The entire digest is used within the EdDSA ed25519 signing algorithm, and a prefix of this digest is used within the record Id. Refer to the BLAKE3 github page","title":"Hashing with BLAKE3"},{"location":"cryptography.html#digital-signature-with-eddsa-ed25519","text":"We use EdDSA with the ed25519 curve rat in a non-standard way. In particular We use ed25519ph, pre-hashed. We substitute BLAKE3 for SHA-512. We provide a context string of \"Mosaic\". We require very specific public key and signature validation checks. In particular: Public keys should be rejected if they are one of 8 small order points. Signatures must be rejected if s is not within the range 0..L-1 . Signatures must be rejected if R or A are non-canonical (e.g. verify that |R| >= L and |A| >= L ) Always use cofactor verification (8(S \u00b7 B) \u2212 8R \u2212 8(h \u00b7 A) = 0) not the non-cofactor one, even when not in batch mode.","title":"Digital Signature with EdDSA ed25519"},{"location":"cryptography.html#encryption","text":"Encryption is NOT YET DEFINED at the Mosaic Core level, but may be in the future. Notes on how we might do it: Use ECIES Do the diffie-hellman between an ephemeral keypair generated by the sender and used only once, and one of the recipient's x25519 public keys (published in their key schedule), which is not ephemeral but may nonetheless be frequently rolled over by the recipient. In order for a user to decrypt on any of their devices, they must share the x25519 public key's secret to all of their devices. In order to preserve signing security, these keys are separate from ed25519 signing keys. See keyschedule marker 0x2. See also this page at cryptosys.net","title":"Encryption"},{"location":"filter.html","text":"Filter PAGE STATUS: early draft A filter is a binary structure used within the Core Protocol . It is defined as a contiguous sequence of selectors. Each selector restricts the set of records that the filter matches. For an event to pass the filter, it must pass all the selectors. Most selectors are narrow (e.g. it must be one of the listed authors). Some selectors are wide (any record after a given timestamp). Filters SHOULD include at least one narrow selector in order to narrow down the set of matching events to something reasonable. Software MAY reject filters that do not comply with this requirement. Filters can be up to 65536 bytes long maximum, but this size may not be possible given other constraints. Most types of selectors should only be used once, and provide for multiple values. Tag selectors can be used multiple times, once for each type of tag. The following selectors are defined: type name narrow 0x1 Exclude no 0x4 Author Keys yes 0x5 Signing Keys yes 0x6 Timestamps yes 0x7 Since no 0x8 Until no 0xA Received Since no 0xB Received Until no 0xC Kinds yes 0xD Includes Tag yes 0xE Excludes Tag no Exclude 0x1 Excludes all records with the given IDs or Addresses. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0x1| 0x0 | n | 8 +-------------------------------+ | ID or ADDR prefix bytes 0..8 | 16 +-------------------------------+ | ID or ADDR prefix bytes 8..16 | 24 +-------------------------------+ | ID or ADDR prefx bytes 16..24 | 32 +-------------------------------+ | ID or ADDR prefx bytes 24..32 | 40 +-------------------------------+ | ... additional references | +-------------------------------+ [0:1] - The type 0x1 [1:7] - Zeroed [7:8] - A 1-byte count n of references [*] - A sequence of n 32-byte ID or Address prefixes. Author Keys 0x4 Matches all records authored by any of these keys. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0x4| 0x0 | n | 8 +-------------------------------+ | AUTHOR KEY 1/4 | 16 +-------------------------------+ | AUTHOR KEY 2/4 | 24 +-------------------------------+ | AUTHOR KEY 3/4 | 32 +-------------------------------+ | AUTHOR KEY 4/4 | 40 +-------------------------------+ | ... additional keys.. | +-------------------------------+ [0:1] - The type 0x4 [1:7] - Zeroed [7:8] - A 1-byte count n of author keys [*] - A sequence of n 32-byte author public keys. Signing Keys 0x5 Matches all records signed by any of these keys. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0x5| 0x0 | n | 8 +-------------------------------+ | SIGNING KEY 1/4 | 16 +-------------------------------+ | SIGNING KEY 2/4 | 24 +-------------------------------+ | SIGNING KEY 3/4 | 32 +-------------------------------+ | SIGNING KEY 4/4 | 40 +-------------------------------+ | ... additional keys.. | +-------------------------------+ [0:1] - The type 0x5 [1:7] - Zeroed [7:8] - A 1-byte count n of signing keys [*] - A sequence of n 32-byte signing public keys. Timestamps 0x6 Matches all records that have any of these exact timestamps. Typically used as part of address lookups. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0x6| 0x0 | n | 8 +-------------------------------+ | 0x0 | TIMESTAMP | 16 +-------------------------------+ | ..0x0 | ..TIMESTAMP | 24 +-------------------------------+ [0:1] - The type 0x6 [1:7] - Zeroed [7:8] - A 1-byte count n of timestamp fields [*] - A sequence of n 8-byte fields, each being: [0:2] - Zeroed [2:8] - A six byte timestamp . Since 0x7 Matches all records with a timestamp greater than or equal to this value. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0x7| 0x0 | 8 +-------------------------------+ | 0x0 | TIMESTAMP | 16 +-------------------------------+ [0:1] - The type 0x7 [1:10] - Zeroed [10:16] - A six byte timestamp . Until 0x8 Matches all records with a timestamp less than this value. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0x8| 0x0 | 8 +-------------------------------+ | 0x0 | TIMESTAMP | 16 +-------------------------------+ [0:1] - The type 0x8 [1:10] - Zeroed [10:16] - A six byte timestamp . Received Since 0xA Matches all records that were received by the server at or later than this value. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0xA| 0x0 | 8 +-------------------------------+ | 0x0 | TIMESTAMP | 16 +-------------------------------+ [0:1] - The type 0xA [1:10] - Zeroed [10:16] - A six byte timestamp . Received Until 0xB Matches all records that were received by the server before this value. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0xB| 0x0 | 8 +-------------------------------+ | 0x0 | TIMESTAMP | 16 +-------------------------------+ [0:1] - The type 0xB [1:10] - Zeroed [10:16] - A six byte timestamp . Kinds 0xC Matches all records which are of any one of these kinds. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0xC| 0x0 | n | 8 +-------------------------------+ | KIND | ...KIND | 16 +-------------------------------+ [0:1] - The type 0xC [1:7] - Zeroed [7:8] - A 1-byte count n of kinds [8] - A sequence of n 4-byte kinds Includes Tag 0xD Matches all records that contain the given tag. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0xD|0x0| TTYPE | 0x0 | LEN | 8 +-------------------------------+ | VALUE... . | +-------------------------------+ [0:1] - The type 0xD [1:2] - Zeroed [2:4] - A 2-byte tag type in little-endian format. [4:6] - Zeroed [6:8] - A 2-byte LEN unsigned integer in little-endian format indicating the length of the VALUE [*] - The VALUE of the tag, up to 253 bytes. Excludes Tag 0xE Matches all records that do NOT contain the given tag. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0xE|0x0| TTYPE | 0x0 | LEN | 8 +-------------------------------+ | VALUE... . | +-------------------------------+ [0:1] - The type 0xE [1:2] - Zeroed [2:4] - A 2-byte tag type in little-endian format. [4:6] - Zeroed [6:8] - A 2-byte LEN unsigned integer in little-endian format indicating the length of the VALUE [*] - The VALUE of the tag, up to 253 bytes.","title":"Filter"},{"location":"filter.html#filter","text":"PAGE STATUS: early draft A filter is a binary structure used within the Core Protocol . It is defined as a contiguous sequence of selectors. Each selector restricts the set of records that the filter matches. For an event to pass the filter, it must pass all the selectors. Most selectors are narrow (e.g. it must be one of the listed authors). Some selectors are wide (any record after a given timestamp). Filters SHOULD include at least one narrow selector in order to narrow down the set of matching events to something reasonable. Software MAY reject filters that do not comply with this requirement. Filters can be up to 65536 bytes long maximum, but this size may not be possible given other constraints. Most types of selectors should only be used once, and provide for multiple values. Tag selectors can be used multiple times, once for each type of tag. The following selectors are defined: type name narrow 0x1 Exclude no 0x4 Author Keys yes 0x5 Signing Keys yes 0x6 Timestamps yes 0x7 Since no 0x8 Until no 0xA Received Since no 0xB Received Until no 0xC Kinds yes 0xD Includes Tag yes 0xE Excludes Tag no","title":"Filter"},{"location":"filter.html#exclude","text":"0x1 Excludes all records with the given IDs or Addresses. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0x1| 0x0 | n | 8 +-------------------------------+ | ID or ADDR prefix bytes 0..8 | 16 +-------------------------------+ | ID or ADDR prefix bytes 8..16 | 24 +-------------------------------+ | ID or ADDR prefx bytes 16..24 | 32 +-------------------------------+ | ID or ADDR prefx bytes 24..32 | 40 +-------------------------------+ | ... additional references | +-------------------------------+ [0:1] - The type 0x1 [1:7] - Zeroed [7:8] - A 1-byte count n of references [*] - A sequence of n 32-byte ID or Address prefixes.","title":"Exclude"},{"location":"filter.html#author-keys","text":"0x4 Matches all records authored by any of these keys. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0x4| 0x0 | n | 8 +-------------------------------+ | AUTHOR KEY 1/4 | 16 +-------------------------------+ | AUTHOR KEY 2/4 | 24 +-------------------------------+ | AUTHOR KEY 3/4 | 32 +-------------------------------+ | AUTHOR KEY 4/4 | 40 +-------------------------------+ | ... additional keys.. | +-------------------------------+ [0:1] - The type 0x4 [1:7] - Zeroed [7:8] - A 1-byte count n of author keys [*] - A sequence of n 32-byte author public keys.","title":"Author Keys"},{"location":"filter.html#signing-keys","text":"0x5 Matches all records signed by any of these keys. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0x5| 0x0 | n | 8 +-------------------------------+ | SIGNING KEY 1/4 | 16 +-------------------------------+ | SIGNING KEY 2/4 | 24 +-------------------------------+ | SIGNING KEY 3/4 | 32 +-------------------------------+ | SIGNING KEY 4/4 | 40 +-------------------------------+ | ... additional keys.. | +-------------------------------+ [0:1] - The type 0x5 [1:7] - Zeroed [7:8] - A 1-byte count n of signing keys [*] - A sequence of n 32-byte signing public keys.","title":"Signing Keys"},{"location":"filter.html#timestamps","text":"0x6 Matches all records that have any of these exact timestamps. Typically used as part of address lookups. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0x6| 0x0 | n | 8 +-------------------------------+ | 0x0 | TIMESTAMP | 16 +-------------------------------+ | ..0x0 | ..TIMESTAMP | 24 +-------------------------------+ [0:1] - The type 0x6 [1:7] - Zeroed [7:8] - A 1-byte count n of timestamp fields [*] - A sequence of n 8-byte fields, each being: [0:2] - Zeroed [2:8] - A six byte timestamp .","title":"Timestamps"},{"location":"filter.html#since","text":"0x7 Matches all records with a timestamp greater than or equal to this value. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0x7| 0x0 | 8 +-------------------------------+ | 0x0 | TIMESTAMP | 16 +-------------------------------+ [0:1] - The type 0x7 [1:10] - Zeroed [10:16] - A six byte timestamp .","title":"Since"},{"location":"filter.html#until","text":"0x8 Matches all records with a timestamp less than this value. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0x8| 0x0 | 8 +-------------------------------+ | 0x0 | TIMESTAMP | 16 +-------------------------------+ [0:1] - The type 0x8 [1:10] - Zeroed [10:16] - A six byte timestamp .","title":"Until"},{"location":"filter.html#received-since","text":"0xA Matches all records that were received by the server at or later than this value. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0xA| 0x0 | 8 +-------------------------------+ | 0x0 | TIMESTAMP | 16 +-------------------------------+ [0:1] - The type 0xA [1:10] - Zeroed [10:16] - A six byte timestamp .","title":"Received Since"},{"location":"filter.html#received-until","text":"0xB Matches all records that were received by the server before this value. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0xB| 0x0 | 8 +-------------------------------+ | 0x0 | TIMESTAMP | 16 +-------------------------------+ [0:1] - The type 0xB [1:10] - Zeroed [10:16] - A six byte timestamp .","title":"Received Until"},{"location":"filter.html#kinds","text":"0xC Matches all records which are of any one of these kinds. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0xC| 0x0 | n | 8 +-------------------------------+ | KIND | ...KIND | 16 +-------------------------------+ [0:1] - The type 0xC [1:7] - Zeroed [7:8] - A 1-byte count n of kinds [8] - A sequence of n 4-byte kinds","title":"Kinds"},{"location":"filter.html#includes-tag","text":"0xD Matches all records that contain the given tag. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0xD|0x0| TTYPE | 0x0 | LEN | 8 +-------------------------------+ | VALUE... . | +-------------------------------+ [0:1] - The type 0xD [1:2] - Zeroed [2:4] - A 2-byte tag type in little-endian format. [4:6] - Zeroed [6:8] - A 2-byte LEN unsigned integer in little-endian format indicating the length of the VALUE [*] - The VALUE of the tag, up to 253 bytes.","title":"Includes Tag"},{"location":"filter.html#excludes-tag","text":"0xE Matches all records that do NOT contain the given tag. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0xE|0x0| TTYPE | 0x0 | LEN | 8 +-------------------------------+ | VALUE... . | +-------------------------------+ [0:1] - The type 0xE [1:2] - Zeroed [2:4] - A 2-byte tag type in little-endian format. [4:6] - Zeroed [6:8] - A 2-byte LEN unsigned integer in little-endian format indicating the length of the VALUE [*] - The VALUE of the tag, up to 253 bytes.","title":"Excludes Tag"},{"location":"human_encodings.html","text":"Mosaic Human Encodings Human encodings are defined to provide uniform compatible ways for sharing data between humans and software. zbase32 is used for human-oriented rendering of binary data. Prefixes are used to specify the type of data being represented: Public keys are prefixed with mopub0 Secret keys are prefixed with mosec0 References are prefixed with moref0","title":"Human Encodings"},{"location":"human_encodings.html#mosaic-human-encodings","text":"Human encodings are defined to provide uniform compatible ways for sharing data between humans and software. zbase32 is used for human-oriented rendering of binary data. Prefixes are used to specify the type of data being represented: Public keys are prefixed with mopub0 Secret keys are prefixed with mosec0 References are prefixed with moref0","title":"Mosaic Human Encodings"},{"location":"human_readable_content.html","text":"Human Readable Content Records kinds which contain payloads of human readable content work as follows. The payload MUST be a valid UTF-8 encoded string. Any part of the intended content that is meant to have machine-readable meaning must not be in the payload, but instead specified in a content segment tag, which indicates the kind of content, the character (not byte) offset into the payload where this content should be rendered, and the value of the content. Multiple kinds of content segment tags are defined including: Content Segment: User Mention for things like @user . Content Segment: Server Mention for mentioning a server. Content Segment: Quote for quoting other records. Content Segment: URL for inserting a URL to a website. Content Segment: Image for inserting an image. Content Segment: Video for inserting a video.","title":"Human Readable Content"},{"location":"human_readable_content.html#human-readable-content","text":"Records kinds which contain payloads of human readable content work as follows. The payload MUST be a valid UTF-8 encoded string. Any part of the intended content that is meant to have machine-readable meaning must not be in the payload, but instead specified in a content segment tag, which indicates the kind of content, the character (not byte) offset into the payload where this content should be rendered, and the value of the content. Multiple kinds of content segment tags are defined including: Content Segment: User Mention for things like @user . Content Segment: Server Mention for mentioning a server. Content Segment: Quote for quoting other records. Content Segment: URL for inserting a URL to a website. Content Segment: Image for inserting an image. Content Segment: Video for inserting a video.","title":"Human Readable Content"},{"location":"identity.html","text":"Identity PAGE STATUS: early draft Sovereign Identity Identities in Mosaic are self-created and self-administered. This requires each end user and server to securely manage their secret key material. Convenient methods for doing so are outside of the scope of Mosaic except insomuch as we define master keys and subkeys with the purpose that subkeys are intended for online use, and master keys are intended to be long-term and kept more securely, perhaps being offline, in hardware, or managed by a trusted service. An identity is defined to be the person, organization, or other entity with knowledge of the secret half of an EdDSA keypair. This key pair is considered their master keypair . A user is referenced by the public half of their master keypair . Master keys and Subkeys Users may have subsidiary public keys, known as subkeys , signing keys or device keys (these terms being mostly functionally interchangeable). The purpose of subkeys is for online usage in less secure environments, where compromise and revocation do not invalidate the master key identity that the user is known by. Subkeys also support alternative algorithms, such as X25519 public keys for receiving encrypted information, or secp256k1 keys for backwards compatibility with nostr. Users publish their subkeys in a key schedule record , defined within the core records specification. A limited number of low-frequency operations in Mosaic require a signature from the master key. These include (presently): Publishing/modifying a User Bootstrap listing their servers (or a Server Bootstrap listing it's endpoints) Publishing/modifying a user's Key Schedule with new keys and/or revocations. Publishing/modifying a user's Profile record. Subkeys might be deterministically derived from the master secret key, or they might not. Nothing in the Mosaic spec requires such, but some implementations may make use of this. Users versus Servers Identities are split between Users and Servers. Servers provide an infrastructure service. Users rely on the service provided by servers.","title":"Identity"},{"location":"identity.html#identity","text":"PAGE STATUS: early draft","title":"Identity"},{"location":"identity.html#sovereign-identity","text":"Identities in Mosaic are self-created and self-administered. This requires each end user and server to securely manage their secret key material. Convenient methods for doing so are outside of the scope of Mosaic except insomuch as we define master keys and subkeys with the purpose that subkeys are intended for online use, and master keys are intended to be long-term and kept more securely, perhaps being offline, in hardware, or managed by a trusted service. An identity is defined to be the person, organization, or other entity with knowledge of the secret half of an EdDSA keypair. This key pair is considered their master keypair . A user is referenced by the public half of their master keypair .","title":"Sovereign Identity"},{"location":"identity.html#master-keys-and-subkeys","text":"Users may have subsidiary public keys, known as subkeys , signing keys or device keys (these terms being mostly functionally interchangeable). The purpose of subkeys is for online usage in less secure environments, where compromise and revocation do not invalidate the master key identity that the user is known by. Subkeys also support alternative algorithms, such as X25519 public keys for receiving encrypted information, or secp256k1 keys for backwards compatibility with nostr. Users publish their subkeys in a key schedule record , defined within the core records specification. A limited number of low-frequency operations in Mosaic require a signature from the master key. These include (presently): Publishing/modifying a User Bootstrap listing their servers (or a Server Bootstrap listing it's endpoints) Publishing/modifying a user's Key Schedule with new keys and/or revocations. Publishing/modifying a user's Profile record. Subkeys might be deterministically derived from the master secret key, or they might not. Nothing in the Mosaic spec requires such, but some implementations may make use of this.","title":"Master keys and Subkeys"},{"location":"identity.html#users-versus-servers","text":"Identities are split between Users and Servers. Servers provide an infrastructure service. Users rely on the service provided by servers.","title":"Users versus Servers"},{"location":"keyschedule.html","text":"Key Schedule Record PAGE STATUS: early draft A key schedule record lists subkey information and revocation information for a master key. A key schedule record has kind 0x1 . A key schedule record MUST be considered invalid if it does not conform to this specification. A key schedule record MUST be considered invalid if the signing key and the master key are not identical. Tags Every subkey listed in a key schedule record must have an associated subkey tag listing the subkey. Payload The payload is not human readable . The payload contains a sequence of 40-byte subkey records laid out as follows: 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ | SUBKEY 1/4 | 8 +-------------------------------+ | SUBKEY 2/4 | 16 +-------------------------------+ | SUBKEY 3/4 | 24 +-------------------------------+ | SUBKEY 4/4 | 32 +-------------------------------+ |MARKER|RES|REVOC TIMESTAMP | +-------------------------------+ [0:32] - SUBKEY is the 32-byte subkey [32:33] - MARKER is 1-byte and is one of the following 0x0 - ACTIVE_SIGNING_KEY - A Mosaic ed25519 signing key (subkey) in current use 0x1 - ACTIVE_ENCRYPTION_KEY - A Mosaic X25519 encryption key in current use These keys are used for receiving encrypted data only, not for signing. Generally the secretkey for encryption is distributed to every device that needs the ability to view encrypted data. Being a separate subkey from the signing keys, it limits the damage from compromise. 0x40 - REVOKED_ALL - All records signed by the key are to be considered invalid. 0x41 - REVOKED_PAST - Records signed by the key that were received prior to the revocation timestamp (based on when it was received by software and NOT based on the date inside of the record) are still considered valid; however, records either received after the revocation timestamp, or with a timestamp after the revocation timestamp, are considered invalid. 0x4F - OUT_OF_USE - Key is no longer in use (but nothing is revoked). This may be used for signing keys or encryption keys. 0x80 - ACTIVE_NOSTR_KEY - A nostr secp256k1 subkey This helps support dual-stack software that works with both nostr and Mosaic. [33:34] - RES is 1-byte and is reserved. It MUST be 0. [34:40] - REVOC TIMESTAMP is 6-bytes and is in the format described in timestamps . Timestamp is required for REVOKED ALL and REVOKED PAST. Timestamp is suggested for OUT_OF_USE. Timestamp SHOULD be zeroed in all other cases. Server Used These are posted to all of the author's Outbox servers.","title":"Key Schedule Record"},{"location":"keyschedule.html#key-schedule-record","text":"PAGE STATUS: early draft A key schedule record lists subkey information and revocation information for a master key. A key schedule record has kind 0x1 . A key schedule record MUST be considered invalid if it does not conform to this specification. A key schedule record MUST be considered invalid if the signing key and the master key are not identical.","title":"Key Schedule Record"},{"location":"keyschedule.html#tags","text":"Every subkey listed in a key schedule record must have an associated subkey tag listing the subkey.","title":"Tags"},{"location":"keyschedule.html#payload","text":"The payload is not human readable . The payload contains a sequence of 40-byte subkey records laid out as follows: 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ | SUBKEY 1/4 | 8 +-------------------------------+ | SUBKEY 2/4 | 16 +-------------------------------+ | SUBKEY 3/4 | 24 +-------------------------------+ | SUBKEY 4/4 | 32 +-------------------------------+ |MARKER|RES|REVOC TIMESTAMP | +-------------------------------+ [0:32] - SUBKEY is the 32-byte subkey [32:33] - MARKER is 1-byte and is one of the following 0x0 - ACTIVE_SIGNING_KEY - A Mosaic ed25519 signing key (subkey) in current use 0x1 - ACTIVE_ENCRYPTION_KEY - A Mosaic X25519 encryption key in current use These keys are used for receiving encrypted data only, not for signing. Generally the secretkey for encryption is distributed to every device that needs the ability to view encrypted data. Being a separate subkey from the signing keys, it limits the damage from compromise. 0x40 - REVOKED_ALL - All records signed by the key are to be considered invalid. 0x41 - REVOKED_PAST - Records signed by the key that were received prior to the revocation timestamp (based on when it was received by software and NOT based on the date inside of the record) are still considered valid; however, records either received after the revocation timestamp, or with a timestamp after the revocation timestamp, are considered invalid. 0x4F - OUT_OF_USE - Key is no longer in use (but nothing is revoked). This may be used for signing keys or encryption keys. 0x80 - ACTIVE_NOSTR_KEY - A nostr secp256k1 subkey This helps support dual-stack software that works with both nostr and Mosaic. [33:34] - RES is 1-byte and is reserved. It MUST be 0. [34:40] - REVOC TIMESTAMP is 6-bytes and is in the format described in timestamps . Timestamp is required for REVOKED ALL and REVOKED PAST. Timestamp is suggested for OUT_OF_USE. Timestamp SHOULD be zeroed in all other cases.","title":"Payload"},{"location":"keyschedule.html#server-used","text":"These are posted to all of the author's Outbox servers.","title":"Server Used"},{"location":"kinds.html","text":"Record Kinds PAGE STATUS: Early Draft Kinds are 2-byte unsigned integers in little-endian format. This page is a Registry of kinds, their name, and the standard that defines them. Refer to their definitions in the standards that define them. Kind Name Standard Server Used 0x1 Key Schedule Mosaic Core Key Schedule Outbox 0x2 Profile Mosaic Core Profile Outbox 0x3 Microblog Root Mosaic Social Media Microblog Root Outbox 0x4 Reply Comment Mosaic Social Media Reply Comment Outbox & Parent Author Inbox 0x5 Blog Post Mosaic Social Media Blog Post Outbox 0x6 Chat Message Mosaic Social Media Chat Message Chat Server","title":"Record Kind Registry"},{"location":"kinds.html#record-kinds","text":"PAGE STATUS: Early Draft Kinds are 2-byte unsigned integers in little-endian format. This page is a Registry of kinds, their name, and the standard that defines them. Refer to their definitions in the standards that define them. Kind Name Standard Server Used 0x1 Key Schedule Mosaic Core Key Schedule Outbox 0x2 Profile Mosaic Core Profile Outbox 0x3 Microblog Root Mosaic Social Media Microblog Root Outbox 0x4 Reply Comment Mosaic Social Media Reply Comment Outbox & Parent Author Inbox 0x5 Blog Post Mosaic Social Media Blog Post Outbox 0x6 Chat Message Mosaic Social Media Chat Message Chat Server","title":"Record Kinds"},{"location":"microblog.html","text":"Microblog PAGE STATUS: incomplete Kind = 0x4 - Root Tags No special tags are defined here, but most core tags apply. Payload The payload follows the Human Readable Content rules. Flags 0x01 ZSTD - may be on or off 0x02 FROMAUTHOR - may be on or off to control distribution. 0x04 TORECIPIENTS - MUST be off. Microblogs are public. 0x08 NOBRIDGE - may be on or off 0x10 EPHEMERAL- MUST be off. Reply comments are not ephemeral. Server Used These are posted to all of the author's Outbox servers.","title":"Microblogging"},{"location":"microblog.html#microblog","text":"PAGE STATUS: incomplete Kind = 0x4 - Root","title":"Microblog"},{"location":"microblog.html#tags","text":"No special tags are defined here, but most core tags apply.","title":"Tags"},{"location":"microblog.html#payload","text":"The payload follows the Human Readable Content rules.","title":"Payload"},{"location":"microblog.html#flags","text":"0x01 ZSTD - may be on or off 0x02 FROMAUTHOR - may be on or off to control distribution. 0x04 TORECIPIENTS - MUST be off. Microblogs are public. 0x08 NOBRIDGE - may be on or off 0x10 EPHEMERAL- MUST be off. Reply comments are not ephemeral.","title":"Flags"},{"location":"microblog.html#server-used","text":"These are posted to all of the author's Outbox servers.","title":"Server Used"},{"location":"profile.html","text":"Profile Record PAGE STATUS: early draft A profile record contains user profile information. A profile record has kind 0x2. A profile record MUST be considered invalid if the signing key and the master key are not identical. The payload is not human readable . Tags No specific tags are defined. Content Content is a CBOR map. All field names are snake-case. The only required field is name . The following fields are available: name - (REQUIRED) this is the user's name, used for @name tagging, containing only typeable ASCII characters. These cannot be guaranteed to be unique. Users are encouraged to choose names that are uncommon if not unique. Clients are encouraged to provide a way for users to disambiguate name collisions such as via a Petname system, which is out of scope of this specification. display_name - this is a name for display purposes which can contain any sort of UTF-8 character. Clients are encouraged to also display name so that users can tag them with @name syntax. about - This is prose where the user can describe themself. avatar - This is a URL to an avatar (e.g. a profile picture) in a standard format (PNG, JPEG, SVG, WebP, GIF, BMP or ICO) expected to be dimensionally square and no bigger than 512x512. website - This is a URL to the user's website. banner - This is a URL to a background picture in a standard format (PNG, JPEG, SVG, WebP, GIF, BMP or ICO) expected to be of size 1024x768 org - A boolean designating that this profile represents an organisation bot - A boolean designating that this profile is a bot lud16 - This is a lightning payment address defined by LUD-16 Additional fields MAY be used. Server Used These are posted to all of the author's Outbox servers.","title":"Profile Record"},{"location":"profile.html#profile-record","text":"PAGE STATUS: early draft A profile record contains user profile information. A profile record has kind 0x2. A profile record MUST be considered invalid if the signing key and the master key are not identical. The payload is not human readable .","title":"Profile Record"},{"location":"profile.html#tags","text":"No specific tags are defined.","title":"Tags"},{"location":"profile.html#content","text":"Content is a CBOR map. All field names are snake-case. The only required field is name . The following fields are available: name - (REQUIRED) this is the user's name, used for @name tagging, containing only typeable ASCII characters. These cannot be guaranteed to be unique. Users are encouraged to choose names that are uncommon if not unique. Clients are encouraged to provide a way for users to disambiguate name collisions such as via a Petname system, which is out of scope of this specification. display_name - this is a name for display purposes which can contain any sort of UTF-8 character. Clients are encouraged to also display name so that users can tag them with @name syntax. about - This is prose where the user can describe themself. avatar - This is a URL to an avatar (e.g. a profile picture) in a standard format (PNG, JPEG, SVG, WebP, GIF, BMP or ICO) expected to be dimensionally square and no bigger than 512x512. website - This is a URL to the user's website. banner - This is a URL to a background picture in a standard format (PNG, JPEG, SVG, WebP, GIF, BMP or ICO) expected to be of size 1024x768 org - A boolean designating that this profile represents an organisation bot - A boolean designating that this profile is a bot lud16 - This is a lightning payment address defined by LUD-16 Additional fields MAY be used.","title":"Content"},{"location":"profile.html#server-used","text":"These are posted to all of the author's Outbox servers.","title":"Server Used"},{"location":"protocol.html","text":"Protocol PAGE STATUS: early draft Protocol message are not separately digitally signed due to the TLS transport and certificate authentication. Protocol Extensions Protocol extension negotiation is done on a transport-by-transport level. For QUIC transport this is done with the initial packet. For WebSockets transport this is done with the X-Mosaic-Extensions header. The following extensions have been defined: Sync Protocol Extension Asynchronous All client messages initiate an action, and all server messages are in response to client messages (NOTE: this may not apply to Mosaic extensions). Yet messaging is asychronous and both sides SHOULD be prepared to deal with a message sent at any time. Servers SHOULD not send messages until they receive a message that requires a response. If a server fails to receive a message from a client that does not have an open query or submission within a reasonable timeframe, it MAY close the connection. If a client receives a server message that was not expected, it MUST ignore it and decide what to do next. In some cases, clients MAY close the connection because the service they were seeking failed. In other cases they MAY try something else. There is no provision for a client to alert a server of an error. Messages Every message starts with a one-byte type, shown below in the header of each type. Following this is the data of the message. Initiator Message Type Client Get 0x1 Client Query 0x2 Client Subscribe 0x3 Client Unsubscribe 0x4 Client Submission 0x5 Server Record 0x80 Server Locally Complete 0x81 Server Query Closed 0x82 Server Submission Result 0x83 Client Messages Get 0x1 This is a query for specific records. It has the following format: 0 1 2 3 4 5 6 7 8 0 +-----------------------------------------------+ | 0x1 | 0x0 | QUERY_ID | 0x0 | 8 +-----------------------------------------------+ | Mixed IDs or ADDRs ... | | ... | +-----------------------------------------------+ [0:1] - The type 0x1 [1:2] - Zeroed [2:4] - QUERY_ID , two bytes which should be made up by the client and used to associate returned Record responses to this request. [4:8] - Zeroed [*] - A sequence of mixed IDs and ADDRs. Note that ADDRs start with a 1 bit, whereas IDs start with a 0 bit, and both of them are 48 bytes long. This is a client initiated message. Servers are expected to reply with: A series of zero or more Record messages representing all the matched records on the server, followed by a Query Closed message. Query 0x2 This is a query for records that closes once served. It has the following format: 0 1 2 3 4 5 6 7 8 0 +-----------------------------------------------+ | 0x2 | 0x0 | QUERY_ID | LIMIT | 8 +-----------------------------------------------+ | FILTER_LEN| 0x0 | 16 +-----------------------------------------------+ | FILTER ... | | ... | +-----------------------------------------------+ [0:1] - The type 0x2 [1:2] - Zeroed [2:4] - QUERY_ID two bytes which should be made up by the client and used to associate returned Record responses to this request. [4:8] - LIMIT , an unsigned integer in little-endian format, specifies the maximum number of responses that the client wishes to receive. A value of 0 indicates unlimited. [8:10] - FILTER_LEN specifies the length of the FILTER in bytes. [10:16] - Zeroed [*] - The FILTER , see Filter . This is a client initiated message. Servers are expected to reply with: a series of zero or more Record messages representing all the matching records on the server initially, followed by a Query Closed message. Queries MUST return results in anti-chronological order, from most recent backwards. Subscribe 0x3 This is a query for records that is kept open after the initial records are served so that newly arriving records that match can be sent to the client immediately. It has the following format: 0 1 2 3 4 5 6 7 8 0 +-----------------------------------------------+ | 0x3 | 0x0 | QUERY_ID | LIMIT | 8 +-----------------------------------------------+ | FILTER_LEN| 0x0 | 16 +-----------------------------------------------+ | FILTER ... | | ... | +-----------------------------------------------+ [0:1] - The type 0x3 [1:2] - Zeroed [2:4] - QUERY_ID , two bytes which should be made up by the client and used to associate returned Record responses to this request. [4:8] - LIMIT , an unsigned integer in little-endian format, specifies the maximum number of responses that the client wishes to receive. A value of 0 indicates unlimited. [8:10] - FILTER_LEN specifies the length of the FILTER in bytes. [10:16] - Zeroed [*] - The FILTER , see Filter . This is a client initiated message. Servers are expected to reply with: a series of zero or more Record messages representing all the matching records on the server initially, followed by a Locally Complete message, potentially followed by zero or more Record messages that flow in to the server after the initial response (so long as the query is still open), or a Query Closed message if the query could not be served. Queries MUST return results in anti-chronological order, from most recent backwards. Unsubscribe 0x4 This is a client request to close an open subscription query. It has the following format: 0 1 2 3 4 5 6 7 8 0 +-----------------------------------------------+ | 0x4 | 0x0 | QUERY_ID | 0x0 | 8 +-----------------------------------------------+ [0:1] - The type 0x3 [1:2] - Zeroed [2:4] - QUERY_ID , two bytes indicating which query should be closed. [4:8] - Zeroed This is a client initiated message. Servers are expected to reply with: Query Closed Submission 0x5 This is the submission of a record. It has the following format: 0 1 2 3 4 5 6 7 8 0 +-----------------------------------------------+ | 0x5 | LENGTH | 0x0 | 8 +-----------------------------------------------+ | RECORD ... | | ... | +-----------------------------------------------+ [0:1] - The type 0x5 [1:4] - LENGTH is a 24-bit little-endian length, with a maximum value of the max length of a record (1024576 bytes) and representing the actual length of the subsequent record submitted. [5:8] - Zeroed [*] - RECORD is the record submitted This is a client initiated message. Servers are expected to reply with: Submission Result with an id prefix matching the record. Server Messages Record 0x80 This is a record returned from a query. It has the following format: 0 1 2 3 4 5 6 7 8 0 +-----------------------------------------------+ | 0x80| 0x0 | QUERY_ID | 0x0 | LENGTH | 8 +-----------------------------------------------+ | RECORD ... | | ... | +-----------------------------------------------+ [0:1] - The type 0x80 [1:2] - Zeroed [2:4] - QUERY_ID indicates the client query that this record matched. [4:5] - Zeroed [5:8] - LENGTH is a 24-bit little-endian length, with a maximum value of the max length of a record (1024576 bytes) and representing the actual length of the subsequent record supplied. [*] - RECORD is the returned record. This is a server response message in response to Get or Query or Subscribe . Locally Complete 0x81 This is a message indicating that a query has served all matching local records, but remains open to serve matching records that subsequently arrive. It has the following format: 0 1 2 3 4 5 6 7 8 0 +-----------------------------------------------+ | 0x81| 0x0 | Query_ID | 0x0 | 8 +-----------------------------------------------+ [0:1] - The type 0x81 [1:2] - Zeroed [2:4] - QUERY_ID indicates the client query that is now locally complete. [4:8] - zeroed This is a server response message in response to Subscribe . Query Closed 0x82 This is a message indicating that a query has been closed. It has the following format: 0 1 2 3 4 5 6 7 8 0 +-----------------------------------------------+ | 0x82| CODE| Query_ID | 0x0 | 8 +-----------------------------------------------+ [0:1] - The type 0x82 [1:2] - CODE indicates the reason for closure from among the following defined reasons: ON_REQUEST : 0x1 - In response to Unsubscribe REJECTED_INVALID : 0x10 - Query was rejected due to being invalid REJECTED_TOO_OPEN : 0x11 - Query was rejected due to being too open (scraping too many records) REJECTED_TOO_FAST : 0x12 - Query was rejected due to too many queries (or messages of any type) being submitted recently by this client REJECTED_TEMP_BANNED : 0x13 - Query was rejected due to the client being temporarily banned REJECTED_PERM_BANNED : 0x14 - Query was rejected due to the client being permanently banned SHUTTING_DOWN : 0x30 - The server is shutting down INTERNAL_ERROR : 0xF0 - A server error occured OTHER : 0xFF - Some other reason [2:4] - QUERY_ID indicates the client query that is now closed. [4:8] - zeroed Submission Result 0x83 This is a message returning the result of a Submission . It has the following format: 0 1 2 3 4 5 6 7 8 0 +-----------------------------------------------+ | 0x83|CODE | 0x0 | 8 +-----------------------------------------------+ | ID PREFIX bytes 0..8 | 16 +-----------------------------------------------+ | ID PREFIX bytes 8..16 | 24 +-----------------------------------------------+ | ID PREFIX bytes 16..24 | 32 +-----------------------------------------------+ | ID PREFIX bytes 24..32 | 40 +-----------------------------------------------+ [0:1] - The type 0x83 [1:2] - CODE which indicates the result of the submission from among the following defined results: OK : 0x1 - Record submission was accepted DUPLICATE : 0x2 - Record is a duplicate. Servers may use this or they may optionally use OK in the same circumstance. REJECTED_INVALID : 0x10 - Record is invalid REJECTED_TOO_FAST : 0x12 - Record submission was rejected due to too many submissions (or messages of any type) being made recently by this client REJECTED_TEMP_BANNED : 0x13 - Record submission was rejected due to the client being temporarily banned REJECTED_PERM_BANNED : 0x14 - Record submission was rejected due to the client being permanently banned REJECTED_REQUIRES_AUTHN : 0x15 - Record submission requires authentication but the client is connected anonymously. REJECTED_REQUIRES_AUTHZ : 0x16 - Record submission requires authorization (e.g. an account with the server) which the client user does not have. INTERNAL_ERROR : 0xF0 - A server error occured OTHER : 0xFF - Some other reason [2:8] - Zeroed [8:40] - A 32-byte prefix of the 48-byte Id.","title":"Core Protocol"},{"location":"protocol.html#protocol","text":"PAGE STATUS: early draft Protocol message are not separately digitally signed due to the TLS transport and certificate authentication.","title":"Protocol"},{"location":"protocol.html#protocol-extensions","text":"Protocol extension negotiation is done on a transport-by-transport level. For QUIC transport this is done with the initial packet. For WebSockets transport this is done with the X-Mosaic-Extensions header. The following extensions have been defined: Sync Protocol Extension","title":"Protocol Extensions"},{"location":"protocol.html#asynchronous","text":"All client messages initiate an action, and all server messages are in response to client messages (NOTE: this may not apply to Mosaic extensions). Yet messaging is asychronous and both sides SHOULD be prepared to deal with a message sent at any time. Servers SHOULD not send messages until they receive a message that requires a response. If a server fails to receive a message from a client that does not have an open query or submission within a reasonable timeframe, it MAY close the connection. If a client receives a server message that was not expected, it MUST ignore it and decide what to do next. In some cases, clients MAY close the connection because the service they were seeking failed. In other cases they MAY try something else. There is no provision for a client to alert a server of an error.","title":"Asynchronous"},{"location":"protocol.html#messages","text":"Every message starts with a one-byte type, shown below in the header of each type. Following this is the data of the message. Initiator Message Type Client Get 0x1 Client Query 0x2 Client Subscribe 0x3 Client Unsubscribe 0x4 Client Submission 0x5 Server Record 0x80 Server Locally Complete 0x81 Server Query Closed 0x82 Server Submission Result 0x83","title":"Messages"},{"location":"protocol.html#client-messages","text":"","title":"Client Messages"},{"location":"protocol.html#get","text":"0x1 This is a query for specific records. It has the following format: 0 1 2 3 4 5 6 7 8 0 +-----------------------------------------------+ | 0x1 | 0x0 | QUERY_ID | 0x0 | 8 +-----------------------------------------------+ | Mixed IDs or ADDRs ... | | ... | +-----------------------------------------------+ [0:1] - The type 0x1 [1:2] - Zeroed [2:4] - QUERY_ID , two bytes which should be made up by the client and used to associate returned Record responses to this request. [4:8] - Zeroed [*] - A sequence of mixed IDs and ADDRs. Note that ADDRs start with a 1 bit, whereas IDs start with a 0 bit, and both of them are 48 bytes long. This is a client initiated message. Servers are expected to reply with: A series of zero or more Record messages representing all the matched records on the server, followed by a Query Closed message.","title":"Get"},{"location":"protocol.html#query","text":"0x2 This is a query for records that closes once served. It has the following format: 0 1 2 3 4 5 6 7 8 0 +-----------------------------------------------+ | 0x2 | 0x0 | QUERY_ID | LIMIT | 8 +-----------------------------------------------+ | FILTER_LEN| 0x0 | 16 +-----------------------------------------------+ | FILTER ... | | ... | +-----------------------------------------------+ [0:1] - The type 0x2 [1:2] - Zeroed [2:4] - QUERY_ID two bytes which should be made up by the client and used to associate returned Record responses to this request. [4:8] - LIMIT , an unsigned integer in little-endian format, specifies the maximum number of responses that the client wishes to receive. A value of 0 indicates unlimited. [8:10] - FILTER_LEN specifies the length of the FILTER in bytes. [10:16] - Zeroed [*] - The FILTER , see Filter . This is a client initiated message. Servers are expected to reply with: a series of zero or more Record messages representing all the matching records on the server initially, followed by a Query Closed message. Queries MUST return results in anti-chronological order, from most recent backwards.","title":"Query"},{"location":"protocol.html#subscribe","text":"0x3 This is a query for records that is kept open after the initial records are served so that newly arriving records that match can be sent to the client immediately. It has the following format: 0 1 2 3 4 5 6 7 8 0 +-----------------------------------------------+ | 0x3 | 0x0 | QUERY_ID | LIMIT | 8 +-----------------------------------------------+ | FILTER_LEN| 0x0 | 16 +-----------------------------------------------+ | FILTER ... | | ... | +-----------------------------------------------+ [0:1] - The type 0x3 [1:2] - Zeroed [2:4] - QUERY_ID , two bytes which should be made up by the client and used to associate returned Record responses to this request. [4:8] - LIMIT , an unsigned integer in little-endian format, specifies the maximum number of responses that the client wishes to receive. A value of 0 indicates unlimited. [8:10] - FILTER_LEN specifies the length of the FILTER in bytes. [10:16] - Zeroed [*] - The FILTER , see Filter . This is a client initiated message. Servers are expected to reply with: a series of zero or more Record messages representing all the matching records on the server initially, followed by a Locally Complete message, potentially followed by zero or more Record messages that flow in to the server after the initial response (so long as the query is still open), or a Query Closed message if the query could not be served. Queries MUST return results in anti-chronological order, from most recent backwards.","title":"Subscribe"},{"location":"protocol.html#unsubscribe","text":"0x4 This is a client request to close an open subscription query. It has the following format: 0 1 2 3 4 5 6 7 8 0 +-----------------------------------------------+ | 0x4 | 0x0 | QUERY_ID | 0x0 | 8 +-----------------------------------------------+ [0:1] - The type 0x3 [1:2] - Zeroed [2:4] - QUERY_ID , two bytes indicating which query should be closed. [4:8] - Zeroed This is a client initiated message. Servers are expected to reply with: Query Closed","title":"Unsubscribe"},{"location":"protocol.html#submission","text":"0x5 This is the submission of a record. It has the following format: 0 1 2 3 4 5 6 7 8 0 +-----------------------------------------------+ | 0x5 | LENGTH | 0x0 | 8 +-----------------------------------------------+ | RECORD ... | | ... | +-----------------------------------------------+ [0:1] - The type 0x5 [1:4] - LENGTH is a 24-bit little-endian length, with a maximum value of the max length of a record (1024576 bytes) and representing the actual length of the subsequent record submitted. [5:8] - Zeroed [*] - RECORD is the record submitted This is a client initiated message. Servers are expected to reply with: Submission Result with an id prefix matching the record.","title":"Submission"},{"location":"protocol.html#server-messages","text":"","title":"Server Messages"},{"location":"protocol.html#record","text":"0x80 This is a record returned from a query. It has the following format: 0 1 2 3 4 5 6 7 8 0 +-----------------------------------------------+ | 0x80| 0x0 | QUERY_ID | 0x0 | LENGTH | 8 +-----------------------------------------------+ | RECORD ... | | ... | +-----------------------------------------------+ [0:1] - The type 0x80 [1:2] - Zeroed [2:4] - QUERY_ID indicates the client query that this record matched. [4:5] - Zeroed [5:8] - LENGTH is a 24-bit little-endian length, with a maximum value of the max length of a record (1024576 bytes) and representing the actual length of the subsequent record supplied. [*] - RECORD is the returned record. This is a server response message in response to Get or Query or Subscribe .","title":"Record"},{"location":"protocol.html#locally-complete","text":"0x81 This is a message indicating that a query has served all matching local records, but remains open to serve matching records that subsequently arrive. It has the following format: 0 1 2 3 4 5 6 7 8 0 +-----------------------------------------------+ | 0x81| 0x0 | Query_ID | 0x0 | 8 +-----------------------------------------------+ [0:1] - The type 0x81 [1:2] - Zeroed [2:4] - QUERY_ID indicates the client query that is now locally complete. [4:8] - zeroed This is a server response message in response to Subscribe .","title":"Locally Complete"},{"location":"protocol.html#query-closed","text":"0x82 This is a message indicating that a query has been closed. It has the following format: 0 1 2 3 4 5 6 7 8 0 +-----------------------------------------------+ | 0x82| CODE| Query_ID | 0x0 | 8 +-----------------------------------------------+ [0:1] - The type 0x82 [1:2] - CODE indicates the reason for closure from among the following defined reasons: ON_REQUEST : 0x1 - In response to Unsubscribe REJECTED_INVALID : 0x10 - Query was rejected due to being invalid REJECTED_TOO_OPEN : 0x11 - Query was rejected due to being too open (scraping too many records) REJECTED_TOO_FAST : 0x12 - Query was rejected due to too many queries (or messages of any type) being submitted recently by this client REJECTED_TEMP_BANNED : 0x13 - Query was rejected due to the client being temporarily banned REJECTED_PERM_BANNED : 0x14 - Query was rejected due to the client being permanently banned SHUTTING_DOWN : 0x30 - The server is shutting down INTERNAL_ERROR : 0xF0 - A server error occured OTHER : 0xFF - Some other reason [2:4] - QUERY_ID indicates the client query that is now closed. [4:8] - zeroed","title":"Query Closed"},{"location":"protocol.html#submission-result","text":"0x83 This is a message returning the result of a Submission . It has the following format: 0 1 2 3 4 5 6 7 8 0 +-----------------------------------------------+ | 0x83|CODE | 0x0 | 8 +-----------------------------------------------+ | ID PREFIX bytes 0..8 | 16 +-----------------------------------------------+ | ID PREFIX bytes 8..16 | 24 +-----------------------------------------------+ | ID PREFIX bytes 16..24 | 32 +-----------------------------------------------+ | ID PREFIX bytes 24..32 | 40 +-----------------------------------------------+ [0:1] - The type 0x83 [1:2] - CODE which indicates the result of the submission from among the following defined results: OK : 0x1 - Record submission was accepted DUPLICATE : 0x2 - Record is a duplicate. Servers may use this or they may optionally use OK in the same circumstance. REJECTED_INVALID : 0x10 - Record is invalid REJECTED_TOO_FAST : 0x12 - Record submission was rejected due to too many submissions (or messages of any type) being made recently by this client REJECTED_TEMP_BANNED : 0x13 - Record submission was rejected due to the client being temporarily banned REJECTED_PERM_BANNED : 0x14 - Record submission was rejected due to the client being permanently banned REJECTED_REQUIRES_AUTHN : 0x15 - Record submission requires authentication but the client is connected anonymously. REJECTED_REQUIRES_AUTHZ : 0x16 - Record submission requires authorization (e.g. an account with the server) which the client user does not have. INTERNAL_ERROR : 0xF0 - A server error occured OTHER : 0xFF - Some other reason [2:8] - Zeroed [8:40] - A 32-byte prefix of the 48-byte Id.","title":"Submission Result"},{"location":"quic.html","text":"Mosaic over QUIC PAGE STATUS: Early Draft Mosaic benefits from TLS, but does not benefit from much else that HTTP or WebSockets provide other than framing. But framing is quite easy. QUIC brings a lot of performance and usability benefits such as avoiding head-of-line blocking, fewer roundtrips by design, optional out-of-order delivery, and multiplexing. TLS must be version 1.3 only. Framing We cannot use QUIC datagrams due to unreliability and size limitations. So we open a single bidirectional stream for Mosaic and manage our own framing. Framing is simple: Eight byte length of mosaic message The mosaic message itself Some mosaic messages are already framed, but we do this outer framing because they are not all uniformly framed.","title":"QUIC"},{"location":"quic.html#mosaic-over-quic","text":"PAGE STATUS: Early Draft Mosaic benefits from TLS, but does not benefit from much else that HTTP or WebSockets provide other than framing. But framing is quite easy. QUIC brings a lot of performance and usability benefits such as avoiding head-of-line blocking, fewer roundtrips by design, optional out-of-order delivery, and multiplexing. TLS must be version 1.3 only.","title":"Mosaic over QUIC"},{"location":"quic.html#framing","text":"We cannot use QUIC datagrams due to unreliability and size limitations. So we open a single bidirectional stream for Mosaic and manage our own framing. Framing is simple: Eight byte length of mosaic message The mosaic message itself Some mosaic messages are already framed, but we do this outer framing because they are not all uniformly framed.","title":"Framing"},{"location":"rationale.html","text":"Rationale For brevity, the rationale for various decisions has been elided from its context and linked to this page with rat links. Contents Binary Records BLAKE3 Client-Server Distributed Duplex Communication EdDSA ed25519 Mainline DHT Master-Key Subkey No IP Privacy QUIC Records References Server Identities Sovereign Storing received-at timestamps Timestamps TLS Binary Records The record structure could be JSON, CBOR (or BEVE or similar) or Binary. Encoding Human Readable Extensible Parse Speed Copy to Sign Size JSON yes yes slow copy largest CBOR no yes fast Maybe medium Binary no no NONE NO SMALLEST Except for human readability, CBOR is better than JSON in cases where extensibility is needed. Other than that, binary is better in all respects. We argue that extensibility of the main record is sufficiently done via record kinds, tags and content, and therefore extensibility is not needed for this structure. We sacrifice: Human readability Extensibility We gain: Zero parsing required Zero copying for signing required Smallest size has been achieved BTW: JSON also has character encoding ambiguities. BLAKE3 This is a very fast hash function with 128-bit security. It is even sometimes faster in software than hardware versions of SHA-256, and s about 14x as fast as software versions of SHA-256. It is highly parallelizable and can take advantage of vector instructions. It's predecessor BLAKE was the most analyzed algorithm during the NIST SHA-3 competition. EdDSA ed25519 is defined to use SHA-512 and we are using BLAKE3 as a drop-in replacement, so we have to produce 512-bit hashes. But these do not need to be in the record. What the record needs is some way to index and reference it, and part of the hash (at least 256 bits) is good enough for that purpose. In BLAKE3, hashes are variable size, and smaller outputs are prefixes of longer outputs. We utilize this. Client-Server Mosaic is client-server, not peer-to-peer. Mosaic servers are used in a way that presumes they will be online and available most of the time. Mosaic has built-in redundancy across such servers, but nonetheless a machine that is not even intended or capable of being up all the time (such as a phone or laptop) makes a poor mosaic server. Peer to peer architectures work well for situations when nodes do not need to remain online. Most social media situations instead seek to be always-on. Mosaic caters to the latter. We opt for a dumb-server smart-client design to put more control into the hands of the users. Distributed Centralized systems have a fatal flaw: they can easily be captured and controlled by people you do not agree with such as corporate or government censors or hackers. By having a central point of attack, the entire system can be taken down or damaged by bad actors. Mosaic is desgined to be fully distributed, with no centralized points of failure. There is no central place to bootstrap Mosaic either. We use Mainline DHT's bootstrapping, there are mutiple bootstrap servers and you can run your own. Duplex Communication We base Mosaic on transport protocols that provide duplex communication such as QUIC and Web Sockets. This is in opposition to a request-response architecture such as HTTP REST. This allows either side to initiate an action, which turns out to be a very useful feature. For example when a new record that matches a user's subscribed filters arrives at the server, the server can immediately shuttle it to the client. In a request-response architecture, there would be a delay until the client polled again. And due to the polling nature, the client would need to make many poll requests even when nothing was ready for them. EdDSA ed25519 We chose this elliptic curve because it is the state of the art. It is fast It is space efficient It is widely studied It has very good resistance to side-channel attacks It does not require point validation It interoperates with ssh, gpg, TLS, Mainline DHT, and other modern ed25519-based identity systems We replaced the hashing algorithm because multiple good cryptographers have indicated that any secure hashing algorithm that produces hashes of the right size could be used, and we chose BLAKE3 . We provide a context string so that users cannot be tricked by one application into signing content for a different application (in case users think they can use the same keypair for every application). We added additional checks in order to provide the following guarantees: Existentially and Strongly unforgeable under chosen message attacks Strongly Binding Signature See Taming the many EdDSAs See The Provable Security of Ed25519: Theory and Practice Mainline DHT Mainline DHT is distributed and censorship resistant, including being resistant to (or able to detect) Sybil attacks. It is the largest (or one of) and longest living DHT. It also has this mutable data functionality and works with ed25519 signed data. Salt We use the salt to avoid collisions, in case the same ed25519 identity keypair is used by both mosaic and pubky , or in case we need to change the format of the bootstrap in the future. We also need different salts because we have two different kinds of bootstraps already. Different salts allow a server keypair to also be a user keypair without collision. These salts are short enough to not use too much space. The user bootstrap salt used to be mub24 but was changed to mub25 when the format of printable public keys changed. Sequence Numbers We don't need collision protection here because writing this record requires the secure master key which is likely to be in only one place, and even if copied around we still do not expect people to write often from multiple places. We could change to timestamps instead if this becomes a problem and still remain backwards compatible. Master-Key Subkey Users need to keep their secret key secure so they don't have their identity stolen. But they also need to access their secret key online in order to use the protocol. By splitting the keys into a master key and multiple device keys (or subkeys) we can enable very secure master key storage and usage without impeding the ability to operate online with subkeys. No IP Privacy Several IP privacy network layers exist which already do a good job (Tor, i2p, VPNs). The IP privacy issue is almost entirely orthogonal to the application protocol, and so architecturally it makes sense to separate application layers from privacy layers. There is no good reason to reinvent another privacy layer just for Mosaic since Mosaic can run on top of an already existing general-purpose privacy layer. QUIC HTTP has a lot of baggage. WebSockets layers on top of that. What we really need is size-unrestricted datagrams within TLS. QUIC gives us that if we do our own framing within a QUIC stream. QUIC is widely deployed due to its use in HTTP 1.3. QUIC is also much faster due to fewer roundtrips and no head-of-line blocking, while taking care of TLS, multiplexed streams, congestion control and other details that we would not dare to reimplement. The only concern would be if the port is not opened, and in this case a server can run on UDP port 443 (even though it is not speaking HTTP). Records Maximum Size This is specified so that length fields inside of records can be of a defined fixed number of bits and so that software can make reasonable decisions about buffer sizes. Layout Record layout provides a compromise between being tightly packed and providing 64-bit alignment of fields. All data that needs hashing is contigous so that no data needs to be copied in order to produce the hash. The hash-based id and signature could have appeared before or after, and we have chosen to place them before to give them well defined offsets. Flags A number of record properties that span applications have been conceived of and we provided space to set these. We provided separate flags for application-specific usage. These are quicker to look up than tag-based or content-based flags. Duplicate Timestamp We have the timestamp twice. We had to duplicate it because the big-endian timestamp in the ID is not hashed or signed. Tags Tag values should not be too large as they need to be indexed by relays. Constraining the value to 253 bytes allows an entire TLV (with 16-bit type and 8-bit length) to fit within 256 bytes. While for some tag types a length could be inferred, this is not true in general. Applications should not be required to recognize every tag type to look up its known length or type-specific method of length calculation. Some tag types start with padding in the value in order to better align their data. References Id Fields The hash in the ID cryptographically represents all the data that was hashed. It is 40 bytes long because we needed at least 32 bytes for cryptographic reasons, and because addresses are already 48 bytes long, we used the extra 8 bytes to extend the hash. The entire 512-bit (64 byte) hash is overkill. Even though we have to produce it for the EdDSA ed25519 signature, we don't have to waste precious record space with that entire long hash. By putting the big-endian timestamp at the front of the ID, IDs sort in time order and group temporally (for database performance). The zeroes in the ID maintain 64-bit alignment. Address Fields By not including the hash of content, records can be edited and replaced by the author (where edits make sense). Application will specify which kind of reference to use in which context. By containing the Author public key, record location can be determined through bootstrapping . By containing the kind, records that are edited cannot change their kind. By containing the kind, software can filter records that are not relevant to a situation without needing to look them up first. By containing a long unique nonce, it is statistically infeasible for two different records to have the same address unintentionally. In fact this is overkill, but we had the space due to alignment requirements. By not specifying how the nonce is generated, applications can solve different problems with different requirements. At only 48 bytes long, these can easily fit into a 253 byte tag when needed and are the same size as an ID. By the first bit being a 1, IDs and ADDRs can be intermixed and their type determined by that bit. -- Server Identities By recognizing a server by it's key, we can verify server identity directly. We no longer need to trust DNS, that it gave us the right IP address We no longer need to trust Certification Authorities, that the DNS to IP address binding is correct. Additionally, servers can now present themselves at multiple transport endpoints. By having a strong form of identification, clients can maintain reliable reputational information about servers. Sovereign Ethically, we believe in free speech and empowering individuals. All participation is self-managed and nobody can cancel your account. You manage your own keys. This allows users to be independent of any service provider and to change the servers they use at any time. Mosaic does not depend on upstream DNS providers and Mosaic does not depend on Certification Authorities to issue certificates. We use a dumb-server smart-client model in order to push as much control into the user's realm (the client space) as feasible. Storing received-at timestamps We require clients and servers to store this information for two reasons. The first and most important is for key revocation. Revocation can't be applied to only records in the past judged by timestamps in the records themselves because those timestamps can be forged. By remembering when a record was received, an upper time bound is established, and records prior to that bound can continue to be trusted while records after that bound can be invalidated. Secondly, when synchronizing with a relay, clients want to ask for records they have not gotten yet. They can use this received-at data to avoid missing events that were timestamped earlier but arrived later than the last time they checked for events. Timestamps Leap Seconds UTC is a discontinous time scale that is occasionally adjusted by leap seconds. Unixtime is derived from UTC and is thus also discontinuous. Subtracting two unixtimes could give a time interval that is off by up to 28 seconds (for example when comparing dates before 1 Jan 1972 with today). Milliseconds Millisecond unixtimes only take 6 bytes and in 47 bits give us more than 4000 years before they roll over. Bit 48 The most significant bit of timestamps is set to 0 in case software interprets it as a signed integer, to preserve sorting. TLS We use TLS security because it is heavily researched and state-of-the-art. But we don't use the X.509 certificates as intended since both client and server are known by their public keys, not by DNS names. Instead we use RawPublicKey or self-signed certificates. Clients are authenticated via client-side certificates.","title":"Rationale"},{"location":"rationale.html#rationale","text":"For brevity, the rationale for various decisions has been elided from its context and linked to this page with rat links. Contents Binary Records BLAKE3 Client-Server Distributed Duplex Communication EdDSA ed25519 Mainline DHT Master-Key Subkey No IP Privacy QUIC Records References Server Identities Sovereign Storing received-at timestamps Timestamps TLS","title":"Rationale"},{"location":"rationale.html#binary-records","text":"The record structure could be JSON, CBOR (or BEVE or similar) or Binary. Encoding Human Readable Extensible Parse Speed Copy to Sign Size JSON yes yes slow copy largest CBOR no yes fast Maybe medium Binary no no NONE NO SMALLEST Except for human readability, CBOR is better than JSON in cases where extensibility is needed. Other than that, binary is better in all respects. We argue that extensibility of the main record is sufficiently done via record kinds, tags and content, and therefore extensibility is not needed for this structure. We sacrifice: Human readability Extensibility We gain: Zero parsing required Zero copying for signing required Smallest size has been achieved BTW: JSON also has character encoding ambiguities.","title":"Binary Records"},{"location":"rationale.html#blake3","text":"This is a very fast hash function with 128-bit security. It is even sometimes faster in software than hardware versions of SHA-256, and s about 14x as fast as software versions of SHA-256. It is highly parallelizable and can take advantage of vector instructions. It's predecessor BLAKE was the most analyzed algorithm during the NIST SHA-3 competition. EdDSA ed25519 is defined to use SHA-512 and we are using BLAKE3 as a drop-in replacement, so we have to produce 512-bit hashes. But these do not need to be in the record. What the record needs is some way to index and reference it, and part of the hash (at least 256 bits) is good enough for that purpose. In BLAKE3, hashes are variable size, and smaller outputs are prefixes of longer outputs. We utilize this.","title":"BLAKE3"},{"location":"rationale.html#client-server","text":"Mosaic is client-server, not peer-to-peer. Mosaic servers are used in a way that presumes they will be online and available most of the time. Mosaic has built-in redundancy across such servers, but nonetheless a machine that is not even intended or capable of being up all the time (such as a phone or laptop) makes a poor mosaic server. Peer to peer architectures work well for situations when nodes do not need to remain online. Most social media situations instead seek to be always-on. Mosaic caters to the latter. We opt for a dumb-server smart-client design to put more control into the hands of the users.","title":"Client-Server"},{"location":"rationale.html#distributed","text":"Centralized systems have a fatal flaw: they can easily be captured and controlled by people you do not agree with such as corporate or government censors or hackers. By having a central point of attack, the entire system can be taken down or damaged by bad actors. Mosaic is desgined to be fully distributed, with no centralized points of failure. There is no central place to bootstrap Mosaic either. We use Mainline DHT's bootstrapping, there are mutiple bootstrap servers and you can run your own.","title":"Distributed"},{"location":"rationale.html#duplex-communication","text":"We base Mosaic on transport protocols that provide duplex communication such as QUIC and Web Sockets. This is in opposition to a request-response architecture such as HTTP REST. This allows either side to initiate an action, which turns out to be a very useful feature. For example when a new record that matches a user's subscribed filters arrives at the server, the server can immediately shuttle it to the client. In a request-response architecture, there would be a delay until the client polled again. And due to the polling nature, the client would need to make many poll requests even when nothing was ready for them.","title":"Duplex Communication"},{"location":"rationale.html#eddsa-ed25519","text":"We chose this elliptic curve because it is the state of the art. It is fast It is space efficient It is widely studied It has very good resistance to side-channel attacks It does not require point validation It interoperates with ssh, gpg, TLS, Mainline DHT, and other modern ed25519-based identity systems We replaced the hashing algorithm because multiple good cryptographers have indicated that any secure hashing algorithm that produces hashes of the right size could be used, and we chose BLAKE3 . We provide a context string so that users cannot be tricked by one application into signing content for a different application (in case users think they can use the same keypair for every application). We added additional checks in order to provide the following guarantees: Existentially and Strongly unforgeable under chosen message attacks Strongly Binding Signature See Taming the many EdDSAs See The Provable Security of Ed25519: Theory and Practice","title":"EdDSA ed25519"},{"location":"rationale.html#mainline-dht","text":"Mainline DHT is distributed and censorship resistant, including being resistant to (or able to detect) Sybil attacks. It is the largest (or one of) and longest living DHT. It also has this mutable data functionality and works with ed25519 signed data.","title":"Mainline DHT"},{"location":"rationale.html#salt","text":"We use the salt to avoid collisions, in case the same ed25519 identity keypair is used by both mosaic and pubky , or in case we need to change the format of the bootstrap in the future. We also need different salts because we have two different kinds of bootstraps already. Different salts allow a server keypair to also be a user keypair without collision. These salts are short enough to not use too much space. The user bootstrap salt used to be mub24 but was changed to mub25 when the format of printable public keys changed.","title":"Salt"},{"location":"rationale.html#sequence-numbers","text":"We don't need collision protection here because writing this record requires the secure master key which is likely to be in only one place, and even if copied around we still do not expect people to write often from multiple places. We could change to timestamps instead if this becomes a problem and still remain backwards compatible.","title":"Sequence Numbers"},{"location":"rationale.html#master-key-subkey","text":"Users need to keep their secret key secure so they don't have their identity stolen. But they also need to access their secret key online in order to use the protocol. By splitting the keys into a master key and multiple device keys (or subkeys) we can enable very secure master key storage and usage without impeding the ability to operate online with subkeys.","title":"Master-Key Subkey"},{"location":"rationale.html#no-ip-privacy","text":"Several IP privacy network layers exist which already do a good job (Tor, i2p, VPNs). The IP privacy issue is almost entirely orthogonal to the application protocol, and so architecturally it makes sense to separate application layers from privacy layers. There is no good reason to reinvent another privacy layer just for Mosaic since Mosaic can run on top of an already existing general-purpose privacy layer.","title":"No IP Privacy"},{"location":"rationale.html#quic","text":"HTTP has a lot of baggage. WebSockets layers on top of that. What we really need is size-unrestricted datagrams within TLS. QUIC gives us that if we do our own framing within a QUIC stream. QUIC is widely deployed due to its use in HTTP 1.3. QUIC is also much faster due to fewer roundtrips and no head-of-line blocking, while taking care of TLS, multiplexed streams, congestion control and other details that we would not dare to reimplement. The only concern would be if the port is not opened, and in this case a server can run on UDP port 443 (even though it is not speaking HTTP).","title":"QUIC"},{"location":"rationale.html#records","text":"","title":"Records"},{"location":"rationale.html#maximum-size","text":"This is specified so that length fields inside of records can be of a defined fixed number of bits and so that software can make reasonable decisions about buffer sizes.","title":"Maximum Size"},{"location":"rationale.html#layout","text":"Record layout provides a compromise between being tightly packed and providing 64-bit alignment of fields. All data that needs hashing is contigous so that no data needs to be copied in order to produce the hash. The hash-based id and signature could have appeared before or after, and we have chosen to place them before to give them well defined offsets.","title":"Layout"},{"location":"rationale.html#flags","text":"A number of record properties that span applications have been conceived of and we provided space to set these. We provided separate flags for application-specific usage. These are quicker to look up than tag-based or content-based flags.","title":"Flags"},{"location":"rationale.html#duplicate-timestamp","text":"We have the timestamp twice. We had to duplicate it because the big-endian timestamp in the ID is not hashed or signed.","title":"Duplicate Timestamp"},{"location":"rationale.html#tags","text":"Tag values should not be too large as they need to be indexed by relays. Constraining the value to 253 bytes allows an entire TLV (with 16-bit type and 8-bit length) to fit within 256 bytes. While for some tag types a length could be inferred, this is not true in general. Applications should not be required to recognize every tag type to look up its known length or type-specific method of length calculation. Some tag types start with padding in the value in order to better align their data.","title":"Tags"},{"location":"rationale.html#references","text":"","title":"References"},{"location":"rationale.html#id-fields","text":"The hash in the ID cryptographically represents all the data that was hashed. It is 40 bytes long because we needed at least 32 bytes for cryptographic reasons, and because addresses are already 48 bytes long, we used the extra 8 bytes to extend the hash. The entire 512-bit (64 byte) hash is overkill. Even though we have to produce it for the EdDSA ed25519 signature, we don't have to waste precious record space with that entire long hash. By putting the big-endian timestamp at the front of the ID, IDs sort in time order and group temporally (for database performance). The zeroes in the ID maintain 64-bit alignment.","title":"Id Fields"},{"location":"rationale.html#address-fields","text":"By not including the hash of content, records can be edited and replaced by the author (where edits make sense). Application will specify which kind of reference to use in which context. By containing the Author public key, record location can be determined through bootstrapping . By containing the kind, records that are edited cannot change their kind. By containing the kind, software can filter records that are not relevant to a situation without needing to look them up first. By containing a long unique nonce, it is statistically infeasible for two different records to have the same address unintentionally. In fact this is overkill, but we had the space due to alignment requirements. By not specifying how the nonce is generated, applications can solve different problems with different requirements. At only 48 bytes long, these can easily fit into a 253 byte tag when needed and are the same size as an ID. By the first bit being a 1, IDs and ADDRs can be intermixed and their type determined by that bit. --","title":"Address Fields"},{"location":"rationale.html#server-identities","text":"By recognizing a server by it's key, we can verify server identity directly. We no longer need to trust DNS, that it gave us the right IP address We no longer need to trust Certification Authorities, that the DNS to IP address binding is correct. Additionally, servers can now present themselves at multiple transport endpoints. By having a strong form of identification, clients can maintain reliable reputational information about servers.","title":"Server Identities"},{"location":"rationale.html#sovereign","text":"Ethically, we believe in free speech and empowering individuals. All participation is self-managed and nobody can cancel your account. You manage your own keys. This allows users to be independent of any service provider and to change the servers they use at any time. Mosaic does not depend on upstream DNS providers and Mosaic does not depend on Certification Authorities to issue certificates. We use a dumb-server smart-client model in order to push as much control into the user's realm (the client space) as feasible.","title":"Sovereign"},{"location":"rationale.html#storing-received-at-timestamps","text":"We require clients and servers to store this information for two reasons. The first and most important is for key revocation. Revocation can't be applied to only records in the past judged by timestamps in the records themselves because those timestamps can be forged. By remembering when a record was received, an upper time bound is established, and records prior to that bound can continue to be trusted while records after that bound can be invalidated. Secondly, when synchronizing with a relay, clients want to ask for records they have not gotten yet. They can use this received-at data to avoid missing events that were timestamped earlier but arrived later than the last time they checked for events.","title":"Storing received-at timestamps"},{"location":"rationale.html#timestamps","text":"","title":"Timestamps"},{"location":"rationale.html#leap-seconds","text":"UTC is a discontinous time scale that is occasionally adjusted by leap seconds. Unixtime is derived from UTC and is thus also discontinuous. Subtracting two unixtimes could give a time interval that is off by up to 28 seconds (for example when comparing dates before 1 Jan 1972 with today).","title":"Leap Seconds"},{"location":"rationale.html#milliseconds","text":"Millisecond unixtimes only take 6 bytes and in 47 bits give us more than 4000 years before they roll over.","title":"Milliseconds"},{"location":"rationale.html#bit-48","text":"The most significant bit of timestamps is set to 0 in case software interprets it as a signed integer, to preserve sorting.","title":"Bit 48"},{"location":"rationale.html#tls","text":"We use TLS security because it is heavily researched and state-of-the-art. But we don't use the X.509 certificates as intended since both client and server are known by their public keys, not by DNS names. Instead we use RawPublicKey or self-signed certificates. Clients are authenticated via client-side certificates.","title":"TLS"},{"location":"record.html","text":"Record PAGE STATUS: draft All Mosaic persistent data is stored within Record structures (except for bootstrap data). Notation Byte slice notation [m:n] indicates the bytes including m up to and including the byte n-1 but not including the byte n . For example [8:12] represents bytes 8, 9, 10 and 11. Byte slices that are missing a beginning such as [:64] start at 0. Byte slices that are missing an ending such as [112:] continue until the end of the data. Maximum Size The maximum size rat of a record is 1 mebibyte (1,048,576 bytes). Layout 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ | Signature 1/8 | 8 +-------------------------------+ | Signature 2/8 | 16 +-------------------------------+ | Signature 3/8 | 24 +-------------------------------+ | Signature 4/8 | 32 +-------------------------------+ | Signature 5/8 | 40 +-------------------------------+ | Signature 6/8 | 48 +-------------------------------+ | Signature 7/8 | 56 +-------------------------------+ | Signature 8/8 | 64 +-------------------------------+ <-----| | BE Timestamp | 0 | 72 +-------------------------------+ | | Hash 1/5 | | 80 +-------------------------------+ | | Hash 2/5 | I | 88 +-------------------------------+ D | | Hash 3/5 | | 96 +-------------------------------+ | | Hash 4/5 | | 104 +-------------------------------+ | | Hash 5/5 | | 112 +-------------------------------+ <-----| | Signing public key, 1/4 | 120 +-------------------------------+ | Signing public key, 2/4 | 128 +-------------------------------+ | Signing public key, 3/4 | 136 +-------------------------------+ | Signing public key, 4/4 | 144 +-------------------------------+ <-----| | Unique Address Nonce | | 152 +-------------------------------+ | | Unique Address Nonce | Kind | A | 160 +-------------------------------+ D | | Author public key, 1/4 | D | 168 +-------------------------------+ R | | Author public key, 2/4 | E | 176 +-------------------------------+ S | | Author public key, 3/4 | S | 184 +-------------------------------+ | | Author public key, 4/4 | | 192 +-------------------------------+ <-----| | Flags | Timestamp | 200 +-------------------------------+ |AppFlgs| LenT | LenP | 208 +-------------------------------+ | Tags... | | .. +PADDING | ? +-------------------------------+ | Payload ... | | .. +PADDING | ? +-------------------------------+ Rationale Fields Records contain the following fields. Signature 64 bytes at [0:64] The signature field is the EdDSA ed25519ph signature of the record produced using the construction procedure. ID A 48 byte ID from [64:112] made up of the following three parts. Big-endian Timestamp 6 bytes from [64:70] This is the timestamp, but in big-endian form. This is the first part of the three-part ID. Zeroes 2 bytes of zeroes from [70:72] . This is the second part of the three-part ID. Hash 40 bytes at [72:112] This is the first 40 bytes of the BLAKE3 hash. This is the third part of the three-part ID. Signing Public Key 32 bytes at [112:144] This is the public key of the signing keypair, which is usually a subkey under the author's master keypair (but theoretically could be delegated in some other fashion in the future). Address A 48 byte Address from [144:192] made up of the following three parts. ref Unique Address Nonce 14 bytes at [144:158] . These bytes must start with a 1 bit. These bytes make an address unique (within the context of an author and a kind). They can be created in a number of different ways, depending on the application and its purpose: They can be generated randomly. They can be generated as a big-endian timestamp concatenated with randomly generated data. This is useful when the addresses should sort in time order. They can be the first 14 bytes of a BLAKE3 hash of a fixed slice of bytes. This is useful for applications that require seeking an event by a known fixed string of bytes (and known author and kind). They can be copied from a previous event, to replace that event. The method of creation is determined by the application layer. Kind 2 bytes at [158:160] This is the kind of the record which determines the application this record is part of, which then determines the nature of the non-core tags and the payload. This is represented as an unsigned integer in little-endian format. Author Public Key 32 bytes at [160:192] This is the identity of the author, expressed as a public key from their master EdDSA ed25519 keypair. Flags 2 bytes at [192:194] 0x01 ZSTD - The payload is compressed with Zstd 0x02 FROM_AUTHOR - Servers SHOULD only accept the record from the author (requiring authentication) 0x04 TO_RECIPIENTS - Servers SHOULD only serve the record to people tagged (requiring authentication) 0x08 NO_BRIDGE - Bridges SHOULD NOT propogate the record to other networks (nostr, mastodon, etc) 0x10 EPHEMERAL - The record is ephemeral; Servers should serve it to current subscribers and not keep it. 0x20 - RESERVED and MUST be 0 0x80, 0x40 - Signature scheme: 00 - EDDSA - EdDSA ed25519 (default) 01 - NOSTR - reserved for secp256k1 Schnorr signatures (not in use) 10 - RESERVED 11 - RESERVED NOTE: This only affects the signing key and the signature. The hash is always created with BLAKE3, and the master key is always EdDSA ed25519. This enables using nostr keys as subkeys (the records generated however will not interoperate with nostr-only software). All other bits - RESERVED and MUST be 0 Timestamp 6 bytes at [194:200] This is a timestamp represented in 6 bytes (48 bits) according to timestamps . AppFlgs 2 bytes at [200:202] These are bitflags reserved for use by the specific application based on the kind . LenT 2 bytes at [202:204] representing the length of the tags section in bytes as an unsigned integer in little-endian format. This represents the exact length of the tags section, not counting padding at the end to achieve 64-bit alignment. The maximum tags section length is 65536 bytes. LenTPad This is NOT included in the record, it is calculated. The length of the tags section including padding is called LenTPad and is calculated as (LenT + 7) & !7 LenP 4 bytes at [204:208] representing the length of the payload section in bytes as an unsigned integer in little-endian format. This represents the exact length of the payload section, not counting padding at the end to achieve 64-bit alignment. The maximum payload section length is 1_048_384 bytes (which is the maximum record size minus the header size). LenPPad This is NOT included in the record, it is calculated. The length of the payload section including padding is called LenPPad and is calculated as (LenP + 7) & !7 Tags Varying bytes at [208:208+LenT] These are searchable key-value tags. Tags ref are a maximum of 256 bytes long. All tags are searchable on servers. If an application requires unsearchable tags, these can be defined within that application's payload. Tags are laid out as follows: 0 2 3 256 max +-----------+---------+----------+ | type | length | value ...| +-----------+---------+----------+ Each tag has a 2-byte (16 bit) type [0:2] , a 1-byte (8 bit) length [2:3] , and a value that is at most 253 bytes long [3:] . Tags only have one value. The tags section is padded out to 64-bit alignment. The maximum tags section length is 65536 bytes. Tag types are documented at the Tag Type Registry which includes the defined Core Tags . Payload Varying bytes at [208+LenTPad:208+LenTPad+LenP]. Payload is opaque (at this layer of specification) application-specific data. The payload section is padded out to 64-bit alignment. The maximum payload section length is 1_048_384 bytes (which is the maximum record size minus the header size). Construction Fill in all the data from [112:] . Take a BLAKE3 hash of [112:] , unkeyed, and extend to 64 bytes of output using BLAKE3's finalize_xof() function. This does not directly go into the record. Generate EdDSA ed25519ph pre-hashed signature of the 512-bit hash generated in step 2 using the Signing secret key, and providing the context string of \"Mosaic\". NOTE: ed25519 calls for a SHA-512 hash, but we use a BLAKE3 hash instead. Place the signature at bytes [0:64] . Copy the first 40 bytes of the hash generated in step 2 to [72:112] . Write the timestamp as a 48-bit unsigned big-endian to [64:70] . Set bytes 70 and 71 to 0 (if not already). Validation Records MUST be fully validated by clients. Records MUST be fully validated by servers upon receipt except for the steps marked CLIENTS ONLY. Validation steps The length must be between 208 and 1048576 bytes. The length must equal 208 + LenTPad + LenPPad. The Signing public key must be validated according to the cryptography key validation checks. The Author public key must be validated according to the cryptography key validation checks. CLIENTS ONLY: The Signing public key must be verified to be a non-revoked subkey of the Author via the Author's bootstrap . Take a BLAKE3 hash of [112:] , unkeyed, and extend to 64 bytes of output using BLAKE3's finalize_xof() function. Verify the hash: Compare bytes [0:40] of this hash with bytes [72:112] of the record. They MUST match. Verify the ID timestamp: bytes [64:70] taken as a big-endian 48-bit unsigned integer must equal bytes [194:200] taken as a little-endian unsigned 48-bit integer. Verify the signature: The signature must be a valid EdDSA ed25519 signature of the full 64-byte BLAKE3 hash taken in step 6 with the signing public key. The timestamp and the orig timestamp must be validated according to timestamps . Bytes 70 and 71 must be 0. Reserved flags must be 0. CLIENTS ONLY: Application specific validation should be performed.","title":"Record Format"},{"location":"record.html#record","text":"PAGE STATUS: draft All Mosaic persistent data is stored within Record structures (except for bootstrap data).","title":"Record"},{"location":"record.html#notation","text":"Byte slice notation [m:n] indicates the bytes including m up to and including the byte n-1 but not including the byte n . For example [8:12] represents bytes 8, 9, 10 and 11. Byte slices that are missing a beginning such as [:64] start at 0. Byte slices that are missing an ending such as [112:] continue until the end of the data.","title":"Notation"},{"location":"record.html#maximum-size","text":"The maximum size rat of a record is 1 mebibyte (1,048,576 bytes).","title":"Maximum Size"},{"location":"record.html#layout","text":"1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ | Signature 1/8 | 8 +-------------------------------+ | Signature 2/8 | 16 +-------------------------------+ | Signature 3/8 | 24 +-------------------------------+ | Signature 4/8 | 32 +-------------------------------+ | Signature 5/8 | 40 +-------------------------------+ | Signature 6/8 | 48 +-------------------------------+ | Signature 7/8 | 56 +-------------------------------+ | Signature 8/8 | 64 +-------------------------------+ <-----| | BE Timestamp | 0 | 72 +-------------------------------+ | | Hash 1/5 | | 80 +-------------------------------+ | | Hash 2/5 | I | 88 +-------------------------------+ D | | Hash 3/5 | | 96 +-------------------------------+ | | Hash 4/5 | | 104 +-------------------------------+ | | Hash 5/5 | | 112 +-------------------------------+ <-----| | Signing public key, 1/4 | 120 +-------------------------------+ | Signing public key, 2/4 | 128 +-------------------------------+ | Signing public key, 3/4 | 136 +-------------------------------+ | Signing public key, 4/4 | 144 +-------------------------------+ <-----| | Unique Address Nonce | | 152 +-------------------------------+ | | Unique Address Nonce | Kind | A | 160 +-------------------------------+ D | | Author public key, 1/4 | D | 168 +-------------------------------+ R | | Author public key, 2/4 | E | 176 +-------------------------------+ S | | Author public key, 3/4 | S | 184 +-------------------------------+ | | Author public key, 4/4 | | 192 +-------------------------------+ <-----| | Flags | Timestamp | 200 +-------------------------------+ |AppFlgs| LenT | LenP | 208 +-------------------------------+ | Tags... | | .. +PADDING | ? +-------------------------------+ | Payload ... | | .. +PADDING | ? +-------------------------------+ Rationale","title":"Layout"},{"location":"record.html#fields","text":"Records contain the following fields.","title":"Fields"},{"location":"record.html#signature","text":"64 bytes at [0:64] The signature field is the EdDSA ed25519ph signature of the record produced using the construction procedure.","title":"Signature"},{"location":"record.html#id","text":"A 48 byte ID from [64:112] made up of the following three parts.","title":"ID"},{"location":"record.html#big-endian-timestamp","text":"6 bytes from [64:70] This is the timestamp, but in big-endian form. This is the first part of the three-part ID.","title":"Big-endian Timestamp"},{"location":"record.html#zeroes","text":"2 bytes of zeroes from [70:72] . This is the second part of the three-part ID.","title":"Zeroes"},{"location":"record.html#hash","text":"40 bytes at [72:112] This is the first 40 bytes of the BLAKE3 hash. This is the third part of the three-part ID.","title":"Hash"},{"location":"record.html#signing-public-key","text":"32 bytes at [112:144] This is the public key of the signing keypair, which is usually a subkey under the author's master keypair (but theoretically could be delegated in some other fashion in the future).","title":"Signing Public Key"},{"location":"record.html#address","text":"A 48 byte Address from [144:192] made up of the following three parts. ref","title":"Address"},{"location":"record.html#unique-address-nonce","text":"14 bytes at [144:158] . These bytes must start with a 1 bit. These bytes make an address unique (within the context of an author and a kind). They can be created in a number of different ways, depending on the application and its purpose: They can be generated randomly. They can be generated as a big-endian timestamp concatenated with randomly generated data. This is useful when the addresses should sort in time order. They can be the first 14 bytes of a BLAKE3 hash of a fixed slice of bytes. This is useful for applications that require seeking an event by a known fixed string of bytes (and known author and kind). They can be copied from a previous event, to replace that event. The method of creation is determined by the application layer.","title":"Unique Address Nonce"},{"location":"record.html#kind","text":"2 bytes at [158:160] This is the kind of the record which determines the application this record is part of, which then determines the nature of the non-core tags and the payload. This is represented as an unsigned integer in little-endian format.","title":"Kind"},{"location":"record.html#author-public-key","text":"32 bytes at [160:192] This is the identity of the author, expressed as a public key from their master EdDSA ed25519 keypair.","title":"Author Public Key"},{"location":"record.html#flags","text":"2 bytes at [192:194] 0x01 ZSTD - The payload is compressed with Zstd 0x02 FROM_AUTHOR - Servers SHOULD only accept the record from the author (requiring authentication) 0x04 TO_RECIPIENTS - Servers SHOULD only serve the record to people tagged (requiring authentication) 0x08 NO_BRIDGE - Bridges SHOULD NOT propogate the record to other networks (nostr, mastodon, etc) 0x10 EPHEMERAL - The record is ephemeral; Servers should serve it to current subscribers and not keep it. 0x20 - RESERVED and MUST be 0 0x80, 0x40 - Signature scheme: 00 - EDDSA - EdDSA ed25519 (default) 01 - NOSTR - reserved for secp256k1 Schnorr signatures (not in use) 10 - RESERVED 11 - RESERVED NOTE: This only affects the signing key and the signature. The hash is always created with BLAKE3, and the master key is always EdDSA ed25519. This enables using nostr keys as subkeys (the records generated however will not interoperate with nostr-only software). All other bits - RESERVED and MUST be 0","title":"Flags"},{"location":"record.html#timestamp","text":"6 bytes at [194:200] This is a timestamp represented in 6 bytes (48 bits) according to timestamps .","title":"Timestamp"},{"location":"record.html#appflgs","text":"2 bytes at [200:202] These are bitflags reserved for use by the specific application based on the kind .","title":"AppFlgs"},{"location":"record.html#lent","text":"2 bytes at [202:204] representing the length of the tags section in bytes as an unsigned integer in little-endian format. This represents the exact length of the tags section, not counting padding at the end to achieve 64-bit alignment. The maximum tags section length is 65536 bytes.","title":"LenT"},{"location":"record.html#lentpad","text":"This is NOT included in the record, it is calculated. The length of the tags section including padding is called LenTPad and is calculated as (LenT + 7) & !7","title":"LenTPad"},{"location":"record.html#lenp","text":"4 bytes at [204:208] representing the length of the payload section in bytes as an unsigned integer in little-endian format. This represents the exact length of the payload section, not counting padding at the end to achieve 64-bit alignment. The maximum payload section length is 1_048_384 bytes (which is the maximum record size minus the header size).","title":"LenP"},{"location":"record.html#lenppad","text":"This is NOT included in the record, it is calculated. The length of the payload section including padding is called LenPPad and is calculated as (LenP + 7) & !7","title":"LenPPad"},{"location":"record.html#tags","text":"Varying bytes at [208:208+LenT] These are searchable key-value tags. Tags ref are a maximum of 256 bytes long. All tags are searchable on servers. If an application requires unsearchable tags, these can be defined within that application's payload. Tags are laid out as follows: 0 2 3 256 max +-----------+---------+----------+ | type | length | value ...| +-----------+---------+----------+ Each tag has a 2-byte (16 bit) type [0:2] , a 1-byte (8 bit) length [2:3] , and a value that is at most 253 bytes long [3:] . Tags only have one value. The tags section is padded out to 64-bit alignment. The maximum tags section length is 65536 bytes. Tag types are documented at the Tag Type Registry which includes the defined Core Tags .","title":"Tags"},{"location":"record.html#payload","text":"Varying bytes at [208+LenTPad:208+LenTPad+LenP]. Payload is opaque (at this layer of specification) application-specific data. The payload section is padded out to 64-bit alignment. The maximum payload section length is 1_048_384 bytes (which is the maximum record size minus the header size).","title":"Payload"},{"location":"record.html#construction","text":"Fill in all the data from [112:] . Take a BLAKE3 hash of [112:] , unkeyed, and extend to 64 bytes of output using BLAKE3's finalize_xof() function. This does not directly go into the record. Generate EdDSA ed25519ph pre-hashed signature of the 512-bit hash generated in step 2 using the Signing secret key, and providing the context string of \"Mosaic\". NOTE: ed25519 calls for a SHA-512 hash, but we use a BLAKE3 hash instead. Place the signature at bytes [0:64] . Copy the first 40 bytes of the hash generated in step 2 to [72:112] . Write the timestamp as a 48-bit unsigned big-endian to [64:70] . Set bytes 70 and 71 to 0 (if not already).","title":"Construction"},{"location":"record.html#validation","text":"Records MUST be fully validated by clients. Records MUST be fully validated by servers upon receipt except for the steps marked CLIENTS ONLY. Validation steps The length must be between 208 and 1048576 bytes. The length must equal 208 + LenTPad + LenPPad. The Signing public key must be validated according to the cryptography key validation checks. The Author public key must be validated according to the cryptography key validation checks. CLIENTS ONLY: The Signing public key must be verified to be a non-revoked subkey of the Author via the Author's bootstrap . Take a BLAKE3 hash of [112:] , unkeyed, and extend to 64 bytes of output using BLAKE3's finalize_xof() function. Verify the hash: Compare bytes [0:40] of this hash with bytes [72:112] of the record. They MUST match. Verify the ID timestamp: bytes [64:70] taken as a big-endian 48-bit unsigned integer must equal bytes [194:200] taken as a little-endian unsigned 48-bit integer. Verify the signature: The signature must be a valid EdDSA ed25519 signature of the full 64-byte BLAKE3 hash taken in step 6 with the signing public key. The timestamp and the orig timestamp must be validated according to timestamps . Bytes 70 and 71 must be 0. Reserved flags must be 0. CLIENTS ONLY: Application specific validation should be performed.","title":"Validation"},{"location":"reference.html","text":"References PAGE STATUS: early draft A reference is a pointer from one record to another. Mosaic defines two kinds of references Id Reference An id reference is a pointer to an exact record with no provision for replacement or edits. It contains some hash of the message making it unique. See record for the Id field. Address Reference An address reference rat is a pointer to a group of records that have the same address, which usually represent an initial record and it's subsequent replacements, often (and by default presumably) with the most recent record superceding the older records, but refer to the specific application. An address consists of three fields which are contiguous and in order in the record layout at [128:176] making up 48 bytes. Unique address nonce (14 bytes) starting with a 1 bit, The kind (2 bytes), The the author's public key (32 bytes), An author can replace a record by creating a new record with the same address, in which case the address is copied (the nonce is not randomly generated). Replaced records must then contain the same author key and be of the same kind, and refer to the same unique address nonce. They may however be signed by a different signing keypair or have their flags modified, their tags changed, and their content changed.","title":"References"},{"location":"reference.html#references","text":"PAGE STATUS: early draft A reference is a pointer from one record to another. Mosaic defines two kinds of references","title":"References"},{"location":"reference.html#id-reference","text":"An id reference is a pointer to an exact record with no provision for replacement or edits. It contains some hash of the message making it unique. See record for the Id field.","title":"Id Reference"},{"location":"reference.html#address-reference","text":"An address reference rat is a pointer to a group of records that have the same address, which usually represent an initial record and it's subsequent replacements, often (and by default presumably) with the most recent record superceding the older records, but refer to the specific application. An address consists of three fields which are contiguous and in order in the record layout at [128:176] making up 48 bytes. Unique address nonce (14 bytes) starting with a 1 bit, The kind (2 bytes), The the author's public key (32 bytes), An author can replace a record by creating a new record with the same address, in which case the address is copied (the nonce is not randomly generated). Replaced records must then contain the same author key and be of the same kind, and refer to the same unique address nonce. They may however be signed by a different signing keypair or have their flags modified, their tags changed, and their content changed.","title":"Address Reference"},{"location":"reply_comment.html","text":"Reply Comment PAGE STATUS: incomplete Kind = 0x5 - Reply Comment Payload The payload follows the Human Readable Content rules. Flags 0x01 ZSTD - may be on or off 0x02 FROMAUTHOR - may be on or off to control distribution. 0x04 TORECIPIENTS - may be on or off. 0x08 NOBRIDGE - may be on or off 0x10 EPHEMERAL- MUST be off. Reply comments are not ephemeral. Tags This MUST include exactly one reply tag, either 0x2 or 0x3. This MUST include exactly one root tag, either 0x2 or 0x3. Server Used These are posted to all of the author's Outbox servers and also to all of the parent Record author's Inbox servers.","title":"Reply Comment"},{"location":"reply_comment.html#reply-comment","text":"PAGE STATUS: incomplete Kind = 0x5 - Reply Comment","title":"Reply Comment"},{"location":"reply_comment.html#payload","text":"The payload follows the Human Readable Content rules.","title":"Payload"},{"location":"reply_comment.html#flags","text":"0x01 ZSTD - may be on or off 0x02 FROMAUTHOR - may be on or off to control distribution. 0x04 TORECIPIENTS - may be on or off. 0x08 NOBRIDGE - may be on or off 0x10 EPHEMERAL- MUST be off. Reply comments are not ephemeral.","title":"Flags"},{"location":"reply_comment.html#tags","text":"This MUST include exactly one reply tag, either 0x2 or 0x3. This MUST include exactly one root tag, either 0x2 or 0x3.","title":"Tags"},{"location":"reply_comment.html#server-used","text":"These are posted to all of the author's Outbox servers and also to all of the parent Record author's Inbox servers.","title":"Server Used"},{"location":"status.html","text":"Status and Development PAGE STATUS: early draft Page statuses Page statuses move between these states TBD Incomplete Early Draft Draft (ready for others to review and comment on) Approved xN (N people have approved) Implemented in core Implemented in core + xN (N implementations are known to exist) Superceded (some other page now supercedes this) Note that developers are encouraged to comment on and discuss pages in any status, they don't have to wait for draft status. Versions and Attribution Many people are expected to contribute to Mosaic and as a result there are various divergent viewpoints as to how Mosaic ought to be. As a result, we label this edition as the Mike Dilger edition. You will see this at the bottom of every page. Other Mosaic contributors can fork this and maintain their own editions. The community will eventually settle on something because people want to be compatible. Principles of Design The protocol must be simple enough for multiple implementations to be developed, but simplicity is not the only factor. The protocol must be functional enough to support a wide range of applications beyond just social media. The protocol should not impede high-performance high-throughput implementations. It is ok to do things multiple ways so long as there is one default that all developers implement, and the rest of the \"ways\" are truly optional. For example, we can have multiple transports (QUIC, WebSockets) without all the developers needing to move beyond QUIC, so long as every implementation implements the QUIC transport. Code that isn't required by everybody should be defined outside of core as an extension, transport, or application, as these are all optional. Core Library This specification is being developed in parallel to a core library . The findings from development feed back into this specification.","title":"Status and Development"},{"location":"status.html#status-and-development","text":"PAGE STATUS: early draft","title":"Status and Development"},{"location":"status.html#page-statuses","text":"Page statuses move between these states TBD Incomplete Early Draft Draft (ready for others to review and comment on) Approved xN (N people have approved) Implemented in core Implemented in core + xN (N implementations are known to exist) Superceded (some other page now supercedes this) Note that developers are encouraged to comment on and discuss pages in any status, they don't have to wait for draft status.","title":"Page statuses"},{"location":"status.html#versions-and-attribution","text":"Many people are expected to contribute to Mosaic and as a result there are various divergent viewpoints as to how Mosaic ought to be. As a result, we label this edition as the Mike Dilger edition. You will see this at the bottom of every page. Other Mosaic contributors can fork this and maintain their own editions. The community will eventually settle on something because people want to be compatible.","title":"Versions and Attribution"},{"location":"status.html#principles-of-design","text":"The protocol must be simple enough for multiple implementations to be developed, but simplicity is not the only factor. The protocol must be functional enough to support a wide range of applications beyond just social media. The protocol should not impede high-performance high-throughput implementations. It is ok to do things multiple ways so long as there is one default that all developers implement, and the rest of the \"ways\" are truly optional. For example, we can have multiple transports (QUIC, WebSockets) without all the developers needing to move beyond QUIC, so long as every implementation implements the QUIC transport. Code that isn't required by everybody should be defined outside of core as an extension, transport, or application, as these are all optional.","title":"Principles of Design"},{"location":"status.html#core-library","text":"This specification is being developed in parallel to a core library . The findings from development feed back into this specification.","title":"Core Library"},{"location":"sync_protocol_extension.html","text":"Mosaic Sync Protocol Extension PAGE STATUS: incomplete This extends the protocol with negentropy support. The following messages are added: Client messages Sync Init 0x10 This is the initialization of a negentropy sync of records Sync Data 0x11 This is a data packet within a negentropy sync of records Sync Close 0x12 This is the closing of a negentropy sync of records Server messages Sync Data 0x91 This is a data packet within a negentropy sync of records Sync Error 0x93 This is an indication that negentropy sync has failed","title":"Sync Protocol Extension"},{"location":"sync_protocol_extension.html#mosaic-sync-protocol-extension","text":"PAGE STATUS: incomplete This extends the protocol with negentropy support. The following messages are added:","title":"Mosaic Sync Protocol Extension"},{"location":"sync_protocol_extension.html#client-messages","text":"","title":"Client messages"},{"location":"sync_protocol_extension.html#sync-init","text":"0x10 This is the initialization of a negentropy sync of records","title":"Sync Init"},{"location":"sync_protocol_extension.html#sync-data","text":"0x11 This is a data packet within a negentropy sync of records","title":"Sync Data"},{"location":"sync_protocol_extension.html#sync-close","text":"0x12 This is the closing of a negentropy sync of records","title":"Sync Close"},{"location":"sync_protocol_extension.html#server-messages","text":"","title":"Server messages"},{"location":"sync_protocol_extension.html#sync-data_1","text":"0x91 This is a data packet within a negentropy sync of records","title":"Sync Data"},{"location":"sync_protocol_extension.html#sync-error","text":"0x93 This is an indication that negentropy sync has failed","title":"Sync Error"},{"location":"tag_types.html","text":"Tag types PAGE STATUS: early draft Tag types are 2-byte (16-bit) unsigned integers in little-endian format. Each application registers their tag types here to prevent collision. Mosaic Core defines a few core tags in Core Tags . Tag Type Name Standard 0x1 Notify Public Key Mosaic Core Tags 0x2 Reply by Hash Mosaic Core Tags 0x3 Reply by Addr Mosaic Core Tags 0x4 Root by Hash Mosaic Core Tags 0x5 Root by Addr Mosaic Core Tags 0x8 Nostr Sister Event Mosaic Core Tags 0x10 Subkey Mosaic Core Tags 0x20 Content Segment: User Mention Mosaic Core Tags 0x21 Content Segment: Server Mention Mosaic Core Tags 0x22 Content Segment: Quote by Id Mosaic Core Tags 0x23 Content Segment: Quote by Addr Mosaic Core Tags 0x24 Content Segment: URL Mosaic Core Tags 0x25 Content Segment: Image Mosaic Core Tags 0x26 Content Segment: Video Mosaic Core Tags Application defined tags are TBD.","title":"Tag Type Registry"},{"location":"tag_types.html#tag-types","text":"PAGE STATUS: early draft Tag types are 2-byte (16-bit) unsigned integers in little-endian format. Each application registers their tag types here to prevent collision. Mosaic Core defines a few core tags in Core Tags . Tag Type Name Standard 0x1 Notify Public Key Mosaic Core Tags 0x2 Reply by Hash Mosaic Core Tags 0x3 Reply by Addr Mosaic Core Tags 0x4 Root by Hash Mosaic Core Tags 0x5 Root by Addr Mosaic Core Tags 0x8 Nostr Sister Event Mosaic Core Tags 0x10 Subkey Mosaic Core Tags 0x20 Content Segment: User Mention Mosaic Core Tags 0x21 Content Segment: Server Mention Mosaic Core Tags 0x22 Content Segment: Quote by Id Mosaic Core Tags 0x23 Content Segment: Quote by Addr Mosaic Core Tags 0x24 Content Segment: URL Mosaic Core Tags 0x25 Content Segment: Image Mosaic Core Tags 0x26 Content Segment: Video Mosaic Core Tags Application defined tags are TBD.","title":"Tag types"},{"location":"timestamps.html","text":"Timestamps PAGE STATUS: draft Timestamps are unixtimes, adjusted for leap seconds, expressed in milliseconds rat and encoded into a 48-bit unsigned integer in little-endian format. The first bit is 0 rat . Records that have a 1 bit here SHOULD be ignored. The next 47 bits represent the number of milliseconds that have actually elapsed on the surface of the Earth since the UNIX epoch. The epoch is defined as (these definitions are believed to be equivalent): 1 January 1970 UTC Unixtime 0 NTP timestamp 2208988800 Julian Date 2440587.5 UT1 Julian Date 2440587.5004766666 TT NOTE: the fracton above beyond .5 represents the 9 seconds that UTC was behind TAI, plus the 32.184 seconds that TAI is behind TT. Timestamps account for all leap seconds rat unlike unixtime and unlike NTP timestamps (both of which pretend that leap seconds did not happen). Before 1 Jan 1972, timestamps match unixtime. As of this writing (unixtime 1732829887) the current timetstamp which includes 28 additional leap seconds is 1732829915. Since computers tend to be synchronized with UTC for the time being, your software will need to be aware of leap seconds so it can adjust. Leap second data is available at the IANA leap second list The data should be interpreted as follows: The leftmost column is an NTP timestamp. Subtract 2_208_988_800 from it to get a unixtime. The rightmost column is an adjustment to TAI. Subtract 9 from it to get the number of leapseconds that have elapsed as of the time in the first column and thereafter (until the next entry). A timestamp is the current unixtime, plus the number of leap seconds that have elapsed. Refer to the IANA leap second list","title":"Timestamps"},{"location":"timestamps.html#timestamps","text":"PAGE STATUS: draft Timestamps are unixtimes, adjusted for leap seconds, expressed in milliseconds rat and encoded into a 48-bit unsigned integer in little-endian format. The first bit is 0 rat . Records that have a 1 bit here SHOULD be ignored. The next 47 bits represent the number of milliseconds that have actually elapsed on the surface of the Earth since the UNIX epoch. The epoch is defined as (these definitions are believed to be equivalent): 1 January 1970 UTC Unixtime 0 NTP timestamp 2208988800 Julian Date 2440587.5 UT1 Julian Date 2440587.5004766666 TT NOTE: the fracton above beyond .5 represents the 9 seconds that UTC was behind TAI, plus the 32.184 seconds that TAI is behind TT. Timestamps account for all leap seconds rat unlike unixtime and unlike NTP timestamps (both of which pretend that leap seconds did not happen). Before 1 Jan 1972, timestamps match unixtime. As of this writing (unixtime 1732829887) the current timetstamp which includes 28 additional leap seconds is 1732829915. Since computers tend to be synchronized with UTC for the time being, your software will need to be aware of leap seconds so it can adjust. Leap second data is available at the IANA leap second list The data should be interpreted as follows: The leftmost column is an NTP timestamp. Subtract 2_208_988_800 from it to get a unixtime. The rightmost column is an adjustment to TAI. Subtract 9 from it to get the number of leapseconds that have elapsed as of the time in the first column and thereafter (until the next entry). A timestamp is the current unixtime, plus the number of leap seconds that have elapsed. Refer to the IANA leap second list","title":"Timestamps"},{"location":"url.html","text":"URL PAGE STATUS: early draft Mosaic servers are located using URLs. Mosaic server URLs are subject to the following rules. Mosaic URLs MUST contain one of the following scheme s: mosaic for Mosaic over QUIC wss for Mosaic over WebSockets Mosaic URLs MUST contain a host . This SHOULD normally be an IP address (either IPv4 or IPv6) but it MAY be a DNS name. DNS names are useful primarily when using Tor (.onion) or I2P (.i2p), but regular DNS may also be used although this is recommended against since DNS can be censored. Mosaic URLs MAY contain a port . If a port is not provided, then the following defaults apply The mosaic default port is 1320. The wss default port is 443. Mosaic URLs MUST specify the root path / . Mosaic URLs MUST not contain a user, password, query, or fragment section. If any of these is found, software MUST prune such information.","title":"URL"},{"location":"url.html#url","text":"PAGE STATUS: early draft Mosaic servers are located using URLs. Mosaic server URLs are subject to the following rules. Mosaic URLs MUST contain one of the following scheme s: mosaic for Mosaic over QUIC wss for Mosaic over WebSockets Mosaic URLs MUST contain a host . This SHOULD normally be an IP address (either IPv4 or IPv6) but it MAY be a DNS name. DNS names are useful primarily when using Tor (.onion) or I2P (.i2p), but regular DNS may also be used although this is recommended against since DNS can be censored. Mosaic URLs MAY contain a port . If a port is not provided, then the following defaults apply The mosaic default port is 1320. The wss default port is 443. Mosaic URLs MUST specify the root path / . Mosaic URLs MUST not contain a user, password, query, or fragment section. If any of these is found, software MUST prune such information.","title":"URL"},{"location":"websockets.html","text":"Mosaic over Websockets PAGE STATUS: Draft TLS Over WebSockets, Mosaic must use TLS version at least 1.2, preferably TLS 1.3 . TLS should specify the EdDSA signature algorithm, using the ed25519 signing keys. TLS certificates shall be either RawPublicKey or self-signed, and use the ed25519 public key (either the server's master public key or the client's signing public key). Servers SHOULD request client-side certificates if they wish to authenticate users. If clients do not provide certificates, they should be considered anonymous. Servers MAY present different services depending on whether a user is authenticated or not. WebSockets Mosaic messages are transported over WebSockets Sec-WebSocket-Protocol Clients must present the Sec-WebSocket-Protocol header field in the handshake with WebSocket with the value mosaic2024 . If this is not presented, a server may either refuse service and close the connection, or presume the connection is nostr (if it is dual-stack). It should not presume the connection is Mosaic. Servers MUST reply with the protocol they have accepted in the same header, at this point being only 'mosaic2024'. This subprotocol is not (as of this writing) registered with IANA, but does not conflict with registered subprotocols. X-Mosaic-Extensions Clients MAY present an X-Mosiac-Extensions header to specify the extentions they support and may wish to use. The value of an X-Mosiac-Extensions header is a list of extension names separated by semicolons. Clients SHOULD NOT present an X-Mosaic-Extensions header in the handshake unless they are not requesting any extensions. The following extension names are defined: SYNC Servers MUST check for an X-Mosaic-Extensions header. If one is specified, split it's contents on semicolons. Remove all extensions you are unable to service. Join these back together and return an X-Mosaic-Extensions header with this string. If that string was empty, use a - instead. Clients MUST check for an X-Mosaic-Extensions header during negotiation, and configure themselves to use only the extensions that the server returned to them, considering - as the empty set. X-Mosaic-Service-Url Servers MAY present a service URL for a website which users can visit in order to manage their relationship with the server (e.g. sign up for an account, make payment, view logs, or anything else that is relevant to that relationship). These kinds of activities are not standardized here. Binary All messages use websockets binary. Messages are formed as the binary message protocol specified in protocol . Each message starts with a single byte indicating the type, followed by the data that such type requires. Clients MUST only send client messages. If a server reads a server message from a client, it SHOULD disconnect. Servers MUST only send server messages. If a client reads a client message from a server, it SHOULD disconnect.","title":"WebSockets"},{"location":"websockets.html#mosaic-over-websockets","text":"PAGE STATUS: Draft","title":"Mosaic over Websockets"},{"location":"websockets.html#tls","text":"Over WebSockets, Mosaic must use TLS version at least 1.2, preferably TLS 1.3 . TLS should specify the EdDSA signature algorithm, using the ed25519 signing keys. TLS certificates shall be either RawPublicKey or self-signed, and use the ed25519 public key (either the server's master public key or the client's signing public key). Servers SHOULD request client-side certificates if they wish to authenticate users. If clients do not provide certificates, they should be considered anonymous. Servers MAY present different services depending on whether a user is authenticated or not.","title":"TLS"},{"location":"websockets.html#websockets","text":"Mosaic messages are transported over WebSockets","title":"WebSockets"},{"location":"websockets.html#sec-websocket-protocol","text":"Clients must present the Sec-WebSocket-Protocol header field in the handshake with WebSocket with the value mosaic2024 . If this is not presented, a server may either refuse service and close the connection, or presume the connection is nostr (if it is dual-stack). It should not presume the connection is Mosaic. Servers MUST reply with the protocol they have accepted in the same header, at this point being only 'mosaic2024'. This subprotocol is not (as of this writing) registered with IANA, but does not conflict with registered subprotocols.","title":"Sec-WebSocket-Protocol"},{"location":"websockets.html#x-mosaic-extensions","text":"Clients MAY present an X-Mosiac-Extensions header to specify the extentions they support and may wish to use. The value of an X-Mosiac-Extensions header is a list of extension names separated by semicolons. Clients SHOULD NOT present an X-Mosaic-Extensions header in the handshake unless they are not requesting any extensions. The following extension names are defined: SYNC Servers MUST check for an X-Mosaic-Extensions header. If one is specified, split it's contents on semicolons. Remove all extensions you are unable to service. Join these back together and return an X-Mosaic-Extensions header with this string. If that string was empty, use a - instead. Clients MUST check for an X-Mosaic-Extensions header during negotiation, and configure themselves to use only the extensions that the server returned to them, considering - as the empty set.","title":"X-Mosaic-Extensions"},{"location":"websockets.html#x-mosaic-service-url","text":"Servers MAY present a service URL for a website which users can visit in order to manage their relationship with the server (e.g. sign up for an account, make payment, view logs, or anything else that is relevant to that relationship). These kinds of activities are not standardized here.","title":"X-Mosaic-Service-Url"},{"location":"websockets.html#binary","text":"All messages use websockets binary. Messages are formed as the binary message protocol specified in protocol . Each message starts with a single byte indicating the type, followed by the data that such type requires. Clients MUST only send client messages. If a server reads a server message from a client, it SHOULD disconnect. Servers MUST only send server messages. If a client reads a client message from a server, it SHOULD disconnect.","title":"Binary"}]}