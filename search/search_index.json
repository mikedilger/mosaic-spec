{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Mosaic PAGE STATUS: early draft Introduction Mosaic is a distributed sovereign general-purpose application protocol for the Internet. distributed : There is no central point of failure, or place that can be taken down. There is no central place to \"bootstrap\" Mosaic (we use Mainline DHT's bootstrapping, there are mutiple and you can run your own). sovereign : All nodes (users/clients and servers) participation is self-managed and nobody can cancel your account. You manage your own keys. Mosaic does not depend on DNS and Mosaic does not depend on Certification Authorities to issue certificates. general-purpose : Although it started as social media, this architecture has been shown to serve many general-purpose applications. Mosaic is a work in progress . This specification is EARLY DRAFT. What Mosaic is not Mosaic is NOT peer-to-peer : Around the turn of the century, a lot of distributed sovereign protocol work focused on peer-to-peer: Freenet, GnuNET, and later DHTs. As it turns out, peer-to-peer is difficult because most computers are not fully connected to the Internet. And as there is nothing particular difficult in running a server that is fully connected to the Internet (given VPS availability), being strictly peer-to-peer doesn't seem advantageous. So we choose the more rock-solid client-server architecture. Mosaic does NOT provide IP privacy : Around the turn of the century, a lot of distributed sovereign protocol work focused on IP privacy: Freenet, GnuNET, etc. However, Tor took off as a general privacy layer, and other alternatives exist including i2p and VPNs. Architecturally, it makes sense to separate application layers from privacy layers. There is no good reason to reinvent another privacy layer since Mosaic can run on top of an already existing privacy layer. Where Mosaic came from Mosaic is an offshoot of nostr . Like nostr: Mosaic uses sovereign user-controlled key pairs Mosaic uses WebSockets Mosaic uses client-server architecture, since peer-to-peer has connectivity problems Mosaic doesn't provide IP privacy Unlike nostr: Mosaic uses different cryptography (EdDSA ed25519 and BLAKE3) Mosaic uses subkeys from the start for better key management Mosaic servers have keypair-based identities too, so you can be sure that you are connecting to the right server. Servers are identified by their keypair, not their DNS-based URL. Mosaic WebSockets uses TLS 1.2 or 1.3 with either self-signed certificates or RawPublicKey, so that no dependency is made upon self-proclaimed certificate authority companies. Client authentication by servers is done at the TLS layer where clients also present self-signed or RawPublicKey certificates. Mosaic information (server's IP addresses and user's home server information) is bootstrapped from Mainline DHT Mosaic records are binary, meaning they are smaller, have no parsing overhead, and have no layout or character encoding ambiguities. If you think we should have used CBOR or JSON, Refer to debate: Binary Mosaic records are editable if an application wants them to be, as all records can be addressed either by their hash-based id (not replaceable) or their address (replaceable) and all records have both a hash-based id and an address. Timestamps account for leap seconds (unlike unixtime) and have millisecond accuracy. Clients and Servers remember the time that records are received, so that key revocation can revoke all records received after a certain time, and not rely on the possibly fake timestamps in the records themselves. The specification is layered with Core, Transport, Extensions, and Applications being separate. Only Core and WebSockets are required by all participants. Terminology differences Nostr events are akin to Mosaic records Nostr relays are akin to Mosaic servers The name Mosaic No reason. Just a name. Easy to remember and pronounce. A throwback to the old NCSA Mosaic browser I suppose. It is not an acronym. We always capitalize it even in the middle of a sentence.","title":"Mosaic Introduction"},{"location":"#mosaic","text":"PAGE STATUS: early draft","title":"Mosaic"},{"location":"#introduction","text":"Mosaic is a distributed sovereign general-purpose application protocol for the Internet. distributed : There is no central point of failure, or place that can be taken down. There is no central place to \"bootstrap\" Mosaic (we use Mainline DHT's bootstrapping, there are mutiple and you can run your own). sovereign : All nodes (users/clients and servers) participation is self-managed and nobody can cancel your account. You manage your own keys. Mosaic does not depend on DNS and Mosaic does not depend on Certification Authorities to issue certificates. general-purpose : Although it started as social media, this architecture has been shown to serve many general-purpose applications. Mosaic is a work in progress . This specification is EARLY DRAFT.","title":"Introduction"},{"location":"#what-mosaic-is-not","text":"Mosaic is NOT peer-to-peer : Around the turn of the century, a lot of distributed sovereign protocol work focused on peer-to-peer: Freenet, GnuNET, and later DHTs. As it turns out, peer-to-peer is difficult because most computers are not fully connected to the Internet. And as there is nothing particular difficult in running a server that is fully connected to the Internet (given VPS availability), being strictly peer-to-peer doesn't seem advantageous. So we choose the more rock-solid client-server architecture. Mosaic does NOT provide IP privacy : Around the turn of the century, a lot of distributed sovereign protocol work focused on IP privacy: Freenet, GnuNET, etc. However, Tor took off as a general privacy layer, and other alternatives exist including i2p and VPNs. Architecturally, it makes sense to separate application layers from privacy layers. There is no good reason to reinvent another privacy layer since Mosaic can run on top of an already existing privacy layer.","title":"What Mosaic is not"},{"location":"#where-mosaic-came-from","text":"Mosaic is an offshoot of nostr . Like nostr: Mosaic uses sovereign user-controlled key pairs Mosaic uses WebSockets Mosaic uses client-server architecture, since peer-to-peer has connectivity problems Mosaic doesn't provide IP privacy Unlike nostr: Mosaic uses different cryptography (EdDSA ed25519 and BLAKE3) Mosaic uses subkeys from the start for better key management Mosaic servers have keypair-based identities too, so you can be sure that you are connecting to the right server. Servers are identified by their keypair, not their DNS-based URL. Mosaic WebSockets uses TLS 1.2 or 1.3 with either self-signed certificates or RawPublicKey, so that no dependency is made upon self-proclaimed certificate authority companies. Client authentication by servers is done at the TLS layer where clients also present self-signed or RawPublicKey certificates. Mosaic information (server's IP addresses and user's home server information) is bootstrapped from Mainline DHT Mosaic records are binary, meaning they are smaller, have no parsing overhead, and have no layout or character encoding ambiguities. If you think we should have used CBOR or JSON, Refer to debate: Binary Mosaic records are editable if an application wants them to be, as all records can be addressed either by their hash-based id (not replaceable) or their address (replaceable) and all records have both a hash-based id and an address. Timestamps account for leap seconds (unlike unixtime) and have millisecond accuracy. Clients and Servers remember the time that records are received, so that key revocation can revoke all records received after a certain time, and not rely on the possibly fake timestamps in the records themselves. The specification is layered with Core, Transport, Extensions, and Applications being separate. Only Core and WebSockets are required by all participants. Terminology differences Nostr events are akin to Mosaic records Nostr relays are akin to Mosaic servers","title":"Where Mosaic came from"},{"location":"#the-name-mosaic","text":"No reason. Just a name. Easy to remember and pronounce. A throwback to the old NCSA Mosaic browser I suppose. It is not an acronym. We always capitalize it even in the middle of a sentence.","title":"The name Mosaic"},{"location":"blog/","text":"Blog PAGE STATUS: early draft Kind = 0x6 - Blog post Payload The payload follows the Human Readable Content rules. Flags 0x01 ZSTD - may be on or off 0x02 FROMAUTHOR - may be on or off to control distribution. 0x04 TORECIPIENTS - MUST be off. Blogs are public. 0x08 NOBRIDGE - may be on or off 0x10 EPHEMERAL- MUST be off. Blogs are not ephemeral. Tags Blogs SHOULD not have the following tags: 0x1, 0x2, 0x3, 0x4, 0x5, 0x6. Blogs MAY have 0x7. Server Used These are posted to all of the author's Outbox servers.","title":"Blog"},{"location":"blog/#blog","text":"PAGE STATUS: early draft Kind = 0x6 - Blog post","title":"Blog"},{"location":"blog/#payload","text":"The payload follows the Human Readable Content rules.","title":"Payload"},{"location":"blog/#flags","text":"0x01 ZSTD - may be on or off 0x02 FROMAUTHOR - may be on or off to control distribution. 0x04 TORECIPIENTS - MUST be off. Blogs are public. 0x08 NOBRIDGE - may be on or off 0x10 EPHEMERAL- MUST be off. Blogs are not ephemeral.","title":"Flags"},{"location":"blog/#tags","text":"Blogs SHOULD not have the following tags: 0x1, 0x2, 0x3, 0x4, 0x5, 0x6. Blogs MAY have 0x7.","title":"Tags"},{"location":"blog/#server-used","text":"These are posted to all of the author's Outbox servers.","title":"Server Used"},{"location":"bootstrap/","text":"Bootstrap PAGE STATUS: draft When you first find out about a new public key, you may already know if it represents a user or a server (by the context) or you may not even know that. And you also may not know what servers this key uses to host it's key schedule , and profile information, or to publish it's records or receive messages. We store bootstraps in Mainline DHT. Bootstraps are not records . They have their own format. Mainline DHT We use Mainline DHT to store mutable data signed under an ed25519 signature according to BEP 0044 . Rationale: Mainline DHT is distributed and censorship resistant, including being resistant to (or able to detect) Sybil attacks. It also has this mutable data functionality and works with ed25519 signed data. Limitations: Only 1000 bytes can be reliably stored, and some will be used for bencoding overhead and the salt, leaving us only 983 bytes of usable data. Data must be refreshed periodically otherwise it may be removed after a time. Users are responsible for refreshing data in the Mainline DHT which will disappear over time. Mechanisms for this are out of scope for Mosaic Core. Data storage and retrieval may take a few seconds, and should not be done too frequently. Software SHOULD cache results for at least 2 hours. You need a bootstrap to get started and find peers. router.utorrent.com and router.bittorrent.com are common but could be targetted in an attack. However, you can find many more or setup your own bootstrap-dht . Salt We use a salt of \"msb24\" for server bootstraps and \"mub24\" for user bootstraps. Rationale: We use the salt to avoid collisions, in case the same ed25519 identity keypair is used by both mosaic and pubky , or in case we need to change the format of the bootstrap in the future, and because we have two different kinds of bootstraps already (this allows a server keypair to also be a user keypair without collision). These salts are short enough to not use too much space. Sequence Numbers Sequence numbers should start at 1 and monotonically increase with each write. Rust code There is a rust library to access this called mainline Bootstrap Format Bootstraps (the data after the bencoded prefix) are UTF-8 valid text up to 983 bytes long, and consist of a series of lines separated with a single ASCII Line Feed (LF) character (0x0A, \\n). Lines MUST not have trailing whitespace. Two kinds of bootstraps may be stored, based on whether the identity represents a server or a user. Server Bootstraps Server bootstraps specify the internet locations (protocol, host and port) that the server is available at. A server bootstrap starts with the line S . Each subsequent line in a server bootstrap specifies a pathless URL where the server can be accessed. There can be any number of lines. However, the total length of the data cannot exceed 983 bytes. Pathless URLs MUST contain a scheme and a host, and may optionally contain a port. Pathless URLs must NOT contain user, password, path, query, or fragment sections. If any of those is found in a pathless URL, software MUST prune such information. This includes pruning trailing slashes (which are paths). Only secure transports with TLS are defined. TLS must be version 1.2 or 1.3. The only known schemes currently are wss and https ( https being designated for WebTransport ) The order of the entries expresses the preference or priority. Earlier entries are preferred by the server to later ones. Here are some examples of server bootstrap lines: wss://203.0.113.1 specifies WebSockets with TLS on port 443 at IP address 203.0.113.1 . wss://203.0.113.0:5198 specifies WebSockets with TLS on port 5198 at IP address 203.0.113.0 . wss://myserverlk23lkjsefo8u.onion specifies WebSockets with TLS on port 443 over Tor to onion site myserverlk23lkjsefo8u.onion . wss://[2001::130F::09C0:876A:130B] specifies WebSockets with TLS on port 443 over IPv6 to address 2001::130F::09C0:876A:130B . https://mosaic.example:555 specifies WebTransport with TLS on port 555 to DNS node mosaic.example (https is to be interpreted as WebTransport, not REST). Servers are expected to operate as their own inbox/outbox and encryption server. So they do not require the same data as the user bootstrap. User Bootstrap User bootstraps specify servers that the user uses, and how the user uses them. The order of the entries expresses the preference or priority. Earlier entries are preferred by the user to later ones. A user bootstrap starts with the line U . Each line consists of two parts separated by a single ASCII space. Server Usage Character This first part is a single character that encodes that kind of usage. There are three defined server usages: Outbox - Outbox servers are where users publish public records meant to be read by anyone who is following the person's public content. The key schedule and profile are published here. Inbox - Inbox servers are where users receive records that reference them, and where other users can follow replies to messages created by them. Encryption - Encryption servers function like an inbox but handle private encrypted messages (defined outside of Mosaic core) that only the user can read back. Outbox is indicated by bit 0 ( 1<<0 ) in the character. A 1 bit means the server is an outbox server. Inbox is indicated by bit 1 ( 1<<1 ) in the character. A 1 bit means the server is an inbox server. Encryption is indicated by bit 2 ( 1<<2 ) in the character. A 1 bit means the server is an encryption server. Bits 5 and 6 are always on. This is an ASCII '0' (48, 0x30). However a 0 should never be used as a server usage character as this would indicate no server usages, which is invalid as such a line should not exist. For example, to indicate only outbox usage, use character 1 . To indicate all three usages, use 7 . Conveniently with this encoding the ASCII number also matches the relavant bits. Server Key The second part is the server's public key, encoded using base64 (using the standard alphabet of RFC 4648). This will be 44 characters long ending in an = symbol. Example Here is an example user bootstrap: U 1 FB42YsY/CV2FqlMrI4CNeaZ2LnCHXzXmmdGKA+UsuBc= 3 GQ859t+vK9gfYolOMfGB0VD/+kjk3iGFjxHj0GfhMos= 2 L+RDYOrIKID+eEK81510TJ1pQOQW7kMrA10MwKOu0Iw= 3 uBpfOVe3ooWMnc1RdMbYKBAIcHlfl2FsQU67lK2CJ8A= 6 VKLdex3KykACzM0JpRfduelqwytel1AZGaXuv4sZhfU= Based on size limits of 983 bytes, no more than 20 server entries can be listed (but see below for other limitations on the number of servers). Should servers become unreliable, users can change servers and update these bootstrap entries at any time. Usage of servers and limits on their number Maximums : Users SHOULD list no more than 4 redundant servers of any kind, since more redundancy provides strongly diminishing benefit at a linearly increasing network traffic cost. Software MUST utilize the first four servers of the appropriate kind listed, and MAY tolerate additional servers but optionally MAY ignore additional servers. Minimums : Users SHOULD have at least one outbox and at least one inbox. Users MAY have no encryption servers but they will not be able to receive encrypted messages.","title":"Bootstrap"},{"location":"bootstrap/#bootstrap","text":"PAGE STATUS: draft When you first find out about a new public key, you may already know if it represents a user or a server (by the context) or you may not even know that. And you also may not know what servers this key uses to host it's key schedule , and profile information, or to publish it's records or receive messages. We store bootstraps in Mainline DHT. Bootstraps are not records . They have their own format.","title":"Bootstrap"},{"location":"bootstrap/#mainline-dht","text":"We use Mainline DHT to store mutable data signed under an ed25519 signature according to BEP 0044 . Rationale: Mainline DHT is distributed and censorship resistant, including being resistant to (or able to detect) Sybil attacks. It also has this mutable data functionality and works with ed25519 signed data. Limitations: Only 1000 bytes can be reliably stored, and some will be used for bencoding overhead and the salt, leaving us only 983 bytes of usable data. Data must be refreshed periodically otherwise it may be removed after a time. Users are responsible for refreshing data in the Mainline DHT which will disappear over time. Mechanisms for this are out of scope for Mosaic Core. Data storage and retrieval may take a few seconds, and should not be done too frequently. Software SHOULD cache results for at least 2 hours. You need a bootstrap to get started and find peers. router.utorrent.com and router.bittorrent.com are common but could be targetted in an attack. However, you can find many more or setup your own bootstrap-dht .","title":"Mainline DHT"},{"location":"bootstrap/#salt","text":"We use a salt of \"msb24\" for server bootstraps and \"mub24\" for user bootstraps. Rationale: We use the salt to avoid collisions, in case the same ed25519 identity keypair is used by both mosaic and pubky , or in case we need to change the format of the bootstrap in the future, and because we have two different kinds of bootstraps already (this allows a server keypair to also be a user keypair without collision). These salts are short enough to not use too much space.","title":"Salt"},{"location":"bootstrap/#sequence-numbers","text":"Sequence numbers should start at 1 and monotonically increase with each write.","title":"Sequence Numbers"},{"location":"bootstrap/#rust-code","text":"There is a rust library to access this called mainline","title":"Rust code"},{"location":"bootstrap/#bootstrap-format","text":"Bootstraps (the data after the bencoded prefix) are UTF-8 valid text up to 983 bytes long, and consist of a series of lines separated with a single ASCII Line Feed (LF) character (0x0A, \\n). Lines MUST not have trailing whitespace. Two kinds of bootstraps may be stored, based on whether the identity represents a server or a user.","title":"Bootstrap Format"},{"location":"bootstrap/#server-bootstraps","text":"Server bootstraps specify the internet locations (protocol, host and port) that the server is available at. A server bootstrap starts with the line S . Each subsequent line in a server bootstrap specifies a pathless URL where the server can be accessed. There can be any number of lines. However, the total length of the data cannot exceed 983 bytes. Pathless URLs MUST contain a scheme and a host, and may optionally contain a port. Pathless URLs must NOT contain user, password, path, query, or fragment sections. If any of those is found in a pathless URL, software MUST prune such information. This includes pruning trailing slashes (which are paths). Only secure transports with TLS are defined. TLS must be version 1.2 or 1.3. The only known schemes currently are wss and https ( https being designated for WebTransport ) The order of the entries expresses the preference or priority. Earlier entries are preferred by the server to later ones. Here are some examples of server bootstrap lines: wss://203.0.113.1 specifies WebSockets with TLS on port 443 at IP address 203.0.113.1 . wss://203.0.113.0:5198 specifies WebSockets with TLS on port 5198 at IP address 203.0.113.0 . wss://myserverlk23lkjsefo8u.onion specifies WebSockets with TLS on port 443 over Tor to onion site myserverlk23lkjsefo8u.onion . wss://[2001::130F::09C0:876A:130B] specifies WebSockets with TLS on port 443 over IPv6 to address 2001::130F::09C0:876A:130B . https://mosaic.example:555 specifies WebTransport with TLS on port 555 to DNS node mosaic.example (https is to be interpreted as WebTransport, not REST). Servers are expected to operate as their own inbox/outbox and encryption server. So they do not require the same data as the user bootstrap.","title":"Server Bootstraps"},{"location":"bootstrap/#user-bootstrap","text":"User bootstraps specify servers that the user uses, and how the user uses them. The order of the entries expresses the preference or priority. Earlier entries are preferred by the user to later ones. A user bootstrap starts with the line U . Each line consists of two parts separated by a single ASCII space.","title":"User Bootstrap"},{"location":"bootstrap/#server-usage-character","text":"This first part is a single character that encodes that kind of usage. There are three defined server usages: Outbox - Outbox servers are where users publish public records meant to be read by anyone who is following the person's public content. The key schedule and profile are published here. Inbox - Inbox servers are where users receive records that reference them, and where other users can follow replies to messages created by them. Encryption - Encryption servers function like an inbox but handle private encrypted messages (defined outside of Mosaic core) that only the user can read back. Outbox is indicated by bit 0 ( 1<<0 ) in the character. A 1 bit means the server is an outbox server. Inbox is indicated by bit 1 ( 1<<1 ) in the character. A 1 bit means the server is an inbox server. Encryption is indicated by bit 2 ( 1<<2 ) in the character. A 1 bit means the server is an encryption server. Bits 5 and 6 are always on. This is an ASCII '0' (48, 0x30). However a 0 should never be used as a server usage character as this would indicate no server usages, which is invalid as such a line should not exist. For example, to indicate only outbox usage, use character 1 . To indicate all three usages, use 7 . Conveniently with this encoding the ASCII number also matches the relavant bits.","title":"Server Usage Character"},{"location":"bootstrap/#server-key","text":"The second part is the server's public key, encoded using base64 (using the standard alphabet of RFC 4648). This will be 44 characters long ending in an = symbol.","title":"Server Key"},{"location":"bootstrap/#example","text":"Here is an example user bootstrap: U 1 FB42YsY/CV2FqlMrI4CNeaZ2LnCHXzXmmdGKA+UsuBc= 3 GQ859t+vK9gfYolOMfGB0VD/+kjk3iGFjxHj0GfhMos= 2 L+RDYOrIKID+eEK81510TJ1pQOQW7kMrA10MwKOu0Iw= 3 uBpfOVe3ooWMnc1RdMbYKBAIcHlfl2FsQU67lK2CJ8A= 6 VKLdex3KykACzM0JpRfduelqwytel1AZGaXuv4sZhfU= Based on size limits of 983 bytes, no more than 20 server entries can be listed (but see below for other limitations on the number of servers). Should servers become unreliable, users can change servers and update these bootstrap entries at any time.","title":"Example"},{"location":"bootstrap/#usage-of-servers-and-limits-on-their-number","text":"Maximums : Users SHOULD list no more than 4 redundant servers of any kind, since more redundancy provides strongly diminishing benefit at a linearly increasing network traffic cost. Software MUST utilize the first four servers of the appropriate kind listed, and MAY tolerate additional servers but optionally MAY ignore additional servers. Minimums : Users SHOULD have at least one outbox and at least one inbox. Users MAY have no encryption servers but they will not be able to receive encrypted messages.","title":"Usage of servers and limits on their number"},{"location":"chat/","text":"Chat PAGE STATUS: early draft Kind = 0x7 - chat message Payload The payload follows the Human Readable Content rules. Flags 0x01 ZSTD - may be on or off 0x02 FROMAUTHOR - may be on or off 0x04 TORECIPIENTS - may be on or off 0x08 NOBRIDGE - may be on or off 0x10 EPHEMERAL- SHOULD be on Tags This MAY include up to one refer tag, either 0x6 or 0x7. Server Used These are posted to a Chat Server.","title":"Chat"},{"location":"chat/#chat","text":"PAGE STATUS: early draft Kind = 0x7 - chat message","title":"Chat"},{"location":"chat/#payload","text":"The payload follows the Human Readable Content rules.","title":"Payload"},{"location":"chat/#flags","text":"0x01 ZSTD - may be on or off 0x02 FROMAUTHOR - may be on or off 0x04 TORECIPIENTS - may be on or off 0x08 NOBRIDGE - may be on or off 0x10 EPHEMERAL- SHOULD be on","title":"Flags"},{"location":"chat/#tags","text":"This MAY include up to one refer tag, either 0x6 or 0x7.","title":"Tags"},{"location":"chat/#server-used","text":"These are posted to a Chat Server.","title":"Server Used"},{"location":"core_tags/","text":"Mosaic Core Tags PAGE STATUS: early draft Tags are laid out as follows: 0 2 3 256 max +-----------+------+----------+ | type | len | value ...| +-----------+------+----------+ [0:2] - The type [2:3] - The length of the entire tag including the 3 byte header This must be at least 3. [3:] - The value, which is at most 253 bytes long. Rationale While for some tag types a length could be inferred, this is not true in general. Applications are not required to recognize every tag type to look up its known length or method of length calculation. Some tag types start with padding in the value in order to better align their data. Notify Public Key 0x1 0 2 3 8 0x0 +-------------------------------+ 0 | 0x1 |0x28| 0x0 | 0x8 +-------------------------------+ 8 | PUBLIC KEY 1/4 | 0x10 +-------------------------------+ 16 | PUBLIC KEY 2/4 | 0x18 +-------------------------------+ 24 | PUBLIC KEY 3/4 | 0x20 +-------------------------------+ 32 | PUBLIC KEY 4/4 | 0x28 +-------------------------------+ 40 [0:2] - The type 0x1 as a little-endian encoded unsigned integer [2:3] - The length 0x28 [3:8] - Zeroed [8:40] - public key (32 bytes) Records with this tag indicate that the record is if interest to the person identified by that public key (as their master key). Being tagged as such, it should be delivered to all of this persons' INBOX servers as specified in their bootstrap record. Reply by Id 0x2 0 2 3 4 8 0x0 +-------------------------------+ 0 | 0x2 |0x28| 0| KIND | 0x8 +-------------------------------+ 8 | ID 1/6 | 0x10 +-------------------------------+ 16 | ID 2/6 | 0x18 +-------------------------------+ 24 | ID 3/6 | 0x20 +-------------------------------+ 32 | ID 4/6 | 0x28 +-------------------------------+ 40 | ID 5/6 | 0x30 +-------------------------------+ 48 | ID 6/6 | 0x38 +-------------------------------+ 56 [0:2] - The type 0x2 as a little-endian encoded unsigned integer [2:3] - The length 0x38 [3:4] - Zeroed [4:8] - The kind [8:56] - The id (48 bytes) This is a reply to another record in a threading sense. KIND is a 4-byte record kind indicating the kind of record that this one replies to. Replies are application-independent and may reference records of any type. This information is provided to prevent lookup of records of kinds that software is not able to or does not wish to handle. ID is a 48-byte id reference to some other record indicating which other record this record replies to. If a record includes this tag, it must also include a Root by Addr tag as well. Reply by Addr 0x3 0 2 3 4 8 0x0 +-------------------------------+ 0 | 0x3 |0x38| 0| KIND | 0x8 +-------------------------------+ 8 | ADDR 1/6 | 0x10 +-------------------------------+ 16 | ADDR 2/6 | 0x18 +-------------------------------+ 24 | ADDR 3/6 | 0x20 +-------------------------------+ 32 | ADDR 4/6 | 0x28 +-------------------------------+ 40 | ADDR 5/6 | 0x30 +-------------------------------+ 48 | ADDR 6/6 | 0x38 +-------------------------------+ 56 [0:2] - The type 0x3 as a little-endian encoded unsigned integer [2:3] - The length 0x38 [3:4] - Zeroed [4:8] - The kind [8:56] - The address (48 bytes) This is a reply to another record in a threading sense. KIND is a 4-byte record kind indicating the kind of record that this one replies to. Replies are application-independent and may reference records of any type. This information is provided to prevent lookup of records of kinds that software is not able to or does not wish to handle. ADDR is a 48-byte address reference to some other record indicating which other record this record replies to. If a record includes this tag, it must also include a Root by Addr tag as well. Root by Id 0x4 0 2 3 4 8 0x0 +-------------------------------+ 0 | 0x4 |0x28| 0| KIND | 0x8 +-------------------------------+ 8 | ID 1/6 | 0x10 +-------------------------------+ 16 | ID 2/6 | 0x18 +-------------------------------+ 24 | ID 3/6 | 0x20 +-------------------------------+ 32 | ID 4/6 | 0x28 +-------------------------------+ 40 | ID 5/6 | 0x30 +-------------------------------+ 48 | ID 6/6 | 0x38 +-------------------------------+ 56 [0:2] - The type 0x4 as a little-endian encoded unsigned integer [2:3] - The length 0x28 [3:4] - Zeroed [4:8] - The kind [8:56] - The id (48 bytes) This indicates the root of the reply thread. This is to support loading an entire thread in one round trip. KIND is a 4-byte record kind indicating the kind of record that the root record is. Threads are application-independent and may reference records of any type. This information is provided to prevent lookup of records of kinds that software is not able to or does not wish to handle. ID is a 48-byte id reference to some other record indicating which other record this record replies to. If a record includes this tag, it must also include a Reply by Id or Reply by Addr tag as well. Root by Addr 0x5 0 2 3 4 8 0x0 +-------------------------------+ 0 | 0x5 |0x38| 0| KIND | 0x8 +-------------------------------+ 8 | ADDR 1/4 | 0x10 +-------------------------------+ 16 | ADDR 2/4 | 0x18 +-------------------------------+ 24 | ADDR 3/4 | 0x20 +-------------------------------+ 32 | ADDR 4/4 | 0x28 +-------------------------------+ 40 | ADDR 5/4 | 0x30 +-------------------------------+ 48 | ADDR 6/4 | 0x38 +-------------------------------+ 56 [0:2] - The type 0x5 as a little-endian encoded unsigned integer [2:3] - The length 0x38 [3:4] - Zeroed [4:8] - The kind [8:56] - The address (48 bytes) This indicates the root of the reply thread. This is to support loading an entire thread in one round trip. KIND is a 4-byte record kind indicating the kind of record that the root record is. Threads are application-independent and may reference records of any type. This information is provided to prevent lookup of records of kinds that software is not able to or does not wish to handle. ADDR is a 48-byte address reference to some other record which is the root of the thread. If a record includes this tag, it must also include a Reply by Id or Reply by Addr tag as well. Nostr Sister Event 0x8 0 2 3 8 0x0 +-------------------------------+ 0 | 0x8 |0x28| 0x0 | 0x8 +-------------------------------+ 8 | NOSTR ID 1/4 | 0x10 +-------------------------------+ 16 | NOSTR ID 2/4 | 0x18 +-------------------------------+ 24 | NOSTR ID 3/4 | 0x20 +-------------------------------+ 32 | NOSTR ID 4/4 | 0x28 +-------------------------------+ 40 [0:2] - The type 0x8 as a little-endian encoded unsigned integer [2:3] - The length 0x38 [3:8] - Zeroed [8:56] - The Nostr ID (32 bytes) For dual-stack clients that produce Nostr events alongside Mosaic records, and who want to track replies on sister events in nostr as well as here in Mosaic, this is a pointer to the sister event in nostr. NOTE: The nostr sister event will have a \"mosaic\" tag that contains the hex of the id of its Mosaic sister record. Content Segment: User Mention 0x20 0 2 3 4 8 0x0 +-------------------------------+ 0 | 0x20 |0x28|0x0| OFFSET | 0x8 +-------------------------------+ 8 | PUBLIC KEY 1/4 | 0x10 +-------------------------------+ 16 | PUBLIC KEY 2/4 | 0x18 +-------------------------------+ 24 | PUBLIC KEY 3/4 | 0x20 +-------------------------------+ 32 | PUBLIC KEY 4/4 | 0x28 +-------------------------------+ 40 [0:2] - The type 0x20 as a little-endian encoded unsigned integer [2:3] - The length 0x28 [3:4] - Zeroed [4:8] - The offset as a little-endian encoded unsigned integer. [8:40] - public key (32 bytes) This is a mention of a person. OFFSET is the offset into the content where the mention appears. PUBLIC_KEY is the master public key of the person mentioned. Note that this is different from a Notify Public Key tag which indicates the event should be delivered to that person. Instead, this tag indicates that a @name for the person should be rendered when rendering the content. Content Segment: Server Mention 0x21 0 2 3 4 8 0x0 +-------------------------------+ 0 | 0x21 |0x28|0x0| OFFSET | 0x8 +-------------------------------+ 8 | PUBLIC KEY 1/4 | 0x10 +-------------------------------+ 16 | PUBLIC KEY 2/4 | 0x18 +-------------------------------+ 24 | PUBLIC KEY 3/4 | 0x20 +-------------------------------+ 32 | PUBLIC KEY 4/4 | 0x28 +-------------------------------+ 40 [0:2] - The type 0x20 as a little-endian encoded unsigned integer [2:3] - The length 0x28 [3:4] - Zeroed [4:8] - The offset as a little-endian encoded unsigned integer. [8:40] - public key (32 bytes) This is a mention of a server. OFFSET is the offset into the content where the mention appears. PUBLIC_KEY is the public key of the server. Content Segment: Quote by Id 0x22 0 2 3 4 8 0x0 +-------------------------------+ 0 | 0x22 |0x40| 0| KIND | 0x8 +-------------------------------+ 8 | 0x0 | OFFSET | 0x10 +-------------------------------+ 16 | ID 1/6 | 0x18 +-------------------------------+ 24 | ID 2/6 | 0x20 +-------------------------------+ 32 | ID 3/6 | 0x28 +-------------------------------+ 40 | ID 4/6 | 0x30 +-------------------------------+ 48 | ID 5/6 | 0x38 +-------------------------------+ 56 | ID 6/6 | 0x40 +-------------------------------+ 64 [0:2] - The type 0x22 as a little-endian encoded unsigned integer [2:3] - The length 0x30 [3:4] - Zeroed [4:8] - The kind of the quoted record [8:12] - Zeroed [12:16] - The offset as a little-endian encoded unsigned integer. [16:64] - The id (48 bytes) of the quoted record KIND is a 4-byte record kind indicating the kind of record that this one replies to. Replies are application-independent and may reference records of any type. This information is provided to prevent lookup of records of kinds that software is not able to or does not wish to handle. OFFSET is the offset into the content where the mention appears. ID is the id of the quoted record. This is a quote of another record by id. Content Segment: Quote by Addr 0x23 0 2 3 4 8 0x0 +-------------------------------+ 0 | 0x23 |0x40| 0| KIND | 0x8 +-------------------------------+ 8 | 0x0 | OFFSET | 0x10 +-------------------------------+ 16 | ADDR 1/4 | 0x18 +-------------------------------+ 24 | ADDR 2/4 | 0x20 +-------------------------------+ 32 | ADDR 3/4 | 0x28 +-------------------------------+ 40 | ADDR 4/4 | 0x30 +-------------------------------+ 48 | ADDR 5/6 | 0x38 +-------------------------------+ 56 | ADDR 6/6 | 0x40 +-------------------------------+ 64 [0:2] - The type 0x23 as a little-endian encoded unsigned integer [2:3] - The length 0x40 [3:4] - Zeroed [4:8] - The kind of the quoted record [8:12] - Zeroed [12:16] - The offset as a little-endian encoded unsigned integer. [16:64] - The address (48 bytes) of the quoted record KIND is a 4-byte record kind indicating the kind of record that this one replies to. Replies are application-independent and may reference records of any type. This information is provided to prevent lookup of records of kinds that software is not able to or does not wish to handle. OFFSET is the offset into the content where the mention appears. ADDR is the address of the quoted record. This is a quote of another record by address. Content Segment: URL 0x24 0 2 3 4 8 0x0 +-------------------------------+ 0 | 0x24 |LEN |0x0| OFFSET | 0x8 +-------------------------------+ 8 | URL... | +-------------------------------+ [0:2] - The type 0x24 as a little-endian encoded unsigned integer [2:3] - The length of the tag (8 + the length of the URL) [3:4] - Zeroed [4:8] - The offset as a little-endian encoded unsigned integer. [8:] - The URL to be included (up to 248 bytes long) OFFSET is the offset into the content where the mention appears. URL is the URL to be inserted at the offset. This is a URL to a web page. Content Segment: Image 0x25 0 2 3 4 8 0x0 +-------------------------------+ 0 | 0x25 |LEN |0x0| OFFSET | 0x8 +-------------------------------+ 8 | URL... | +-------------------------------+ [0:2] - The type 0x25 as a little-endian encoded unsigned integer [2:3] - The length of the tag (8 + the length of the URL) [3:4] - Zeroed [4:8] - The offset as a little-endian encoded unsigned integer. [8:] - The URL to be included (up to 248 bytes long) OFFSET is the offset into the content where the mention appears. URL is the URL to be inserted at the offset. This is a URL to an image Content Segment: Video 0x26 0 2 3 4 8 0x0 +-------------------------------+ 0 | 0x26 |LEN |0x0| OFFSET | 0x8 +-------------------------------+ 8 | URL... | +-------------------------------+ [0:2] - The type 0x26 as a little-endian encoded unsigned integer [2:3] - The length of the tag (8 + the length of the URL) [3:4] - Zeroed [4:8] - The offset as a little-endian encoded unsigned integer. [8:] - The URL to be included (up to 248 bytes long) OFFSET is the offset into the content where the mention appears. URL is the URL to be inserted at the offset. This is a URL to a video","title":"Core Tags"},{"location":"core_tags/#mosaic-core-tags","text":"PAGE STATUS: early draft Tags are laid out as follows: 0 2 3 256 max +-----------+------+----------+ | type | len | value ...| +-----------+------+----------+ [0:2] - The type [2:3] - The length of the entire tag including the 3 byte header This must be at least 3. [3:] - The value, which is at most 253 bytes long. Rationale While for some tag types a length could be inferred, this is not true in general. Applications are not required to recognize every tag type to look up its known length or method of length calculation. Some tag types start with padding in the value in order to better align their data.","title":"Mosaic Core Tags"},{"location":"core_tags/#notify-public-key","text":"0x1 0 2 3 8 0x0 +-------------------------------+ 0 | 0x1 |0x28| 0x0 | 0x8 +-------------------------------+ 8 | PUBLIC KEY 1/4 | 0x10 +-------------------------------+ 16 | PUBLIC KEY 2/4 | 0x18 +-------------------------------+ 24 | PUBLIC KEY 3/4 | 0x20 +-------------------------------+ 32 | PUBLIC KEY 4/4 | 0x28 +-------------------------------+ 40 [0:2] - The type 0x1 as a little-endian encoded unsigned integer [2:3] - The length 0x28 [3:8] - Zeroed [8:40] - public key (32 bytes) Records with this tag indicate that the record is if interest to the person identified by that public key (as their master key). Being tagged as such, it should be delivered to all of this persons' INBOX servers as specified in their bootstrap record.","title":"Notify Public Key"},{"location":"core_tags/#reply-by-id","text":"0x2 0 2 3 4 8 0x0 +-------------------------------+ 0 | 0x2 |0x28| 0| KIND | 0x8 +-------------------------------+ 8 | ID 1/6 | 0x10 +-------------------------------+ 16 | ID 2/6 | 0x18 +-------------------------------+ 24 | ID 3/6 | 0x20 +-------------------------------+ 32 | ID 4/6 | 0x28 +-------------------------------+ 40 | ID 5/6 | 0x30 +-------------------------------+ 48 | ID 6/6 | 0x38 +-------------------------------+ 56 [0:2] - The type 0x2 as a little-endian encoded unsigned integer [2:3] - The length 0x38 [3:4] - Zeroed [4:8] - The kind [8:56] - The id (48 bytes) This is a reply to another record in a threading sense. KIND is a 4-byte record kind indicating the kind of record that this one replies to. Replies are application-independent and may reference records of any type. This information is provided to prevent lookup of records of kinds that software is not able to or does not wish to handle. ID is a 48-byte id reference to some other record indicating which other record this record replies to. If a record includes this tag, it must also include a Root by Addr tag as well.","title":"Reply by Id"},{"location":"core_tags/#reply-by-addr","text":"0x3 0 2 3 4 8 0x0 +-------------------------------+ 0 | 0x3 |0x38| 0| KIND | 0x8 +-------------------------------+ 8 | ADDR 1/6 | 0x10 +-------------------------------+ 16 | ADDR 2/6 | 0x18 +-------------------------------+ 24 | ADDR 3/6 | 0x20 +-------------------------------+ 32 | ADDR 4/6 | 0x28 +-------------------------------+ 40 | ADDR 5/6 | 0x30 +-------------------------------+ 48 | ADDR 6/6 | 0x38 +-------------------------------+ 56 [0:2] - The type 0x3 as a little-endian encoded unsigned integer [2:3] - The length 0x38 [3:4] - Zeroed [4:8] - The kind [8:56] - The address (48 bytes) This is a reply to another record in a threading sense. KIND is a 4-byte record kind indicating the kind of record that this one replies to. Replies are application-independent and may reference records of any type. This information is provided to prevent lookup of records of kinds that software is not able to or does not wish to handle. ADDR is a 48-byte address reference to some other record indicating which other record this record replies to. If a record includes this tag, it must also include a Root by Addr tag as well.","title":"Reply by Addr"},{"location":"core_tags/#root-by-id","text":"0x4 0 2 3 4 8 0x0 +-------------------------------+ 0 | 0x4 |0x28| 0| KIND | 0x8 +-------------------------------+ 8 | ID 1/6 | 0x10 +-------------------------------+ 16 | ID 2/6 | 0x18 +-------------------------------+ 24 | ID 3/6 | 0x20 +-------------------------------+ 32 | ID 4/6 | 0x28 +-------------------------------+ 40 | ID 5/6 | 0x30 +-------------------------------+ 48 | ID 6/6 | 0x38 +-------------------------------+ 56 [0:2] - The type 0x4 as a little-endian encoded unsigned integer [2:3] - The length 0x28 [3:4] - Zeroed [4:8] - The kind [8:56] - The id (48 bytes) This indicates the root of the reply thread. This is to support loading an entire thread in one round trip. KIND is a 4-byte record kind indicating the kind of record that the root record is. Threads are application-independent and may reference records of any type. This information is provided to prevent lookup of records of kinds that software is not able to or does not wish to handle. ID is a 48-byte id reference to some other record indicating which other record this record replies to. If a record includes this tag, it must also include a Reply by Id or Reply by Addr tag as well.","title":"Root by Id"},{"location":"core_tags/#root-by-addr","text":"0x5 0 2 3 4 8 0x0 +-------------------------------+ 0 | 0x5 |0x38| 0| KIND | 0x8 +-------------------------------+ 8 | ADDR 1/4 | 0x10 +-------------------------------+ 16 | ADDR 2/4 | 0x18 +-------------------------------+ 24 | ADDR 3/4 | 0x20 +-------------------------------+ 32 | ADDR 4/4 | 0x28 +-------------------------------+ 40 | ADDR 5/4 | 0x30 +-------------------------------+ 48 | ADDR 6/4 | 0x38 +-------------------------------+ 56 [0:2] - The type 0x5 as a little-endian encoded unsigned integer [2:3] - The length 0x38 [3:4] - Zeroed [4:8] - The kind [8:56] - The address (48 bytes) This indicates the root of the reply thread. This is to support loading an entire thread in one round trip. KIND is a 4-byte record kind indicating the kind of record that the root record is. Threads are application-independent and may reference records of any type. This information is provided to prevent lookup of records of kinds that software is not able to or does not wish to handle. ADDR is a 48-byte address reference to some other record which is the root of the thread. If a record includes this tag, it must also include a Reply by Id or Reply by Addr tag as well.","title":"Root by Addr"},{"location":"core_tags/#nostr-sister-event","text":"0x8 0 2 3 8 0x0 +-------------------------------+ 0 | 0x8 |0x28| 0x0 | 0x8 +-------------------------------+ 8 | NOSTR ID 1/4 | 0x10 +-------------------------------+ 16 | NOSTR ID 2/4 | 0x18 +-------------------------------+ 24 | NOSTR ID 3/4 | 0x20 +-------------------------------+ 32 | NOSTR ID 4/4 | 0x28 +-------------------------------+ 40 [0:2] - The type 0x8 as a little-endian encoded unsigned integer [2:3] - The length 0x38 [3:8] - Zeroed [8:56] - The Nostr ID (32 bytes) For dual-stack clients that produce Nostr events alongside Mosaic records, and who want to track replies on sister events in nostr as well as here in Mosaic, this is a pointer to the sister event in nostr. NOTE: The nostr sister event will have a \"mosaic\" tag that contains the hex of the id of its Mosaic sister record.","title":"Nostr Sister Event"},{"location":"core_tags/#content-segment-user-mention","text":"0x20 0 2 3 4 8 0x0 +-------------------------------+ 0 | 0x20 |0x28|0x0| OFFSET | 0x8 +-------------------------------+ 8 | PUBLIC KEY 1/4 | 0x10 +-------------------------------+ 16 | PUBLIC KEY 2/4 | 0x18 +-------------------------------+ 24 | PUBLIC KEY 3/4 | 0x20 +-------------------------------+ 32 | PUBLIC KEY 4/4 | 0x28 +-------------------------------+ 40 [0:2] - The type 0x20 as a little-endian encoded unsigned integer [2:3] - The length 0x28 [3:4] - Zeroed [4:8] - The offset as a little-endian encoded unsigned integer. [8:40] - public key (32 bytes) This is a mention of a person. OFFSET is the offset into the content where the mention appears. PUBLIC_KEY is the master public key of the person mentioned. Note that this is different from a Notify Public Key tag which indicates the event should be delivered to that person. Instead, this tag indicates that a @name for the person should be rendered when rendering the content.","title":"Content Segment: User Mention"},{"location":"core_tags/#content-segment-server-mention","text":"0x21 0 2 3 4 8 0x0 +-------------------------------+ 0 | 0x21 |0x28|0x0| OFFSET | 0x8 +-------------------------------+ 8 | PUBLIC KEY 1/4 | 0x10 +-------------------------------+ 16 | PUBLIC KEY 2/4 | 0x18 +-------------------------------+ 24 | PUBLIC KEY 3/4 | 0x20 +-------------------------------+ 32 | PUBLIC KEY 4/4 | 0x28 +-------------------------------+ 40 [0:2] - The type 0x20 as a little-endian encoded unsigned integer [2:3] - The length 0x28 [3:4] - Zeroed [4:8] - The offset as a little-endian encoded unsigned integer. [8:40] - public key (32 bytes) This is a mention of a server. OFFSET is the offset into the content where the mention appears. PUBLIC_KEY is the public key of the server.","title":"Content Segment: Server Mention"},{"location":"core_tags/#content-segment-quote-by-id","text":"0x22 0 2 3 4 8 0x0 +-------------------------------+ 0 | 0x22 |0x40| 0| KIND | 0x8 +-------------------------------+ 8 | 0x0 | OFFSET | 0x10 +-------------------------------+ 16 | ID 1/6 | 0x18 +-------------------------------+ 24 | ID 2/6 | 0x20 +-------------------------------+ 32 | ID 3/6 | 0x28 +-------------------------------+ 40 | ID 4/6 | 0x30 +-------------------------------+ 48 | ID 5/6 | 0x38 +-------------------------------+ 56 | ID 6/6 | 0x40 +-------------------------------+ 64 [0:2] - The type 0x22 as a little-endian encoded unsigned integer [2:3] - The length 0x30 [3:4] - Zeroed [4:8] - The kind of the quoted record [8:12] - Zeroed [12:16] - The offset as a little-endian encoded unsigned integer. [16:64] - The id (48 bytes) of the quoted record KIND is a 4-byte record kind indicating the kind of record that this one replies to. Replies are application-independent and may reference records of any type. This information is provided to prevent lookup of records of kinds that software is not able to or does not wish to handle. OFFSET is the offset into the content where the mention appears. ID is the id of the quoted record. This is a quote of another record by id.","title":"Content Segment: Quote by Id"},{"location":"core_tags/#content-segment-quote-by-addr","text":"0x23 0 2 3 4 8 0x0 +-------------------------------+ 0 | 0x23 |0x40| 0| KIND | 0x8 +-------------------------------+ 8 | 0x0 | OFFSET | 0x10 +-------------------------------+ 16 | ADDR 1/4 | 0x18 +-------------------------------+ 24 | ADDR 2/4 | 0x20 +-------------------------------+ 32 | ADDR 3/4 | 0x28 +-------------------------------+ 40 | ADDR 4/4 | 0x30 +-------------------------------+ 48 | ADDR 5/6 | 0x38 +-------------------------------+ 56 | ADDR 6/6 | 0x40 +-------------------------------+ 64 [0:2] - The type 0x23 as a little-endian encoded unsigned integer [2:3] - The length 0x40 [3:4] - Zeroed [4:8] - The kind of the quoted record [8:12] - Zeroed [12:16] - The offset as a little-endian encoded unsigned integer. [16:64] - The address (48 bytes) of the quoted record KIND is a 4-byte record kind indicating the kind of record that this one replies to. Replies are application-independent and may reference records of any type. This information is provided to prevent lookup of records of kinds that software is not able to or does not wish to handle. OFFSET is the offset into the content where the mention appears. ADDR is the address of the quoted record. This is a quote of another record by address.","title":"Content Segment: Quote by Addr"},{"location":"core_tags/#content-segment-url","text":"0x24 0 2 3 4 8 0x0 +-------------------------------+ 0 | 0x24 |LEN |0x0| OFFSET | 0x8 +-------------------------------+ 8 | URL... | +-------------------------------+ [0:2] - The type 0x24 as a little-endian encoded unsigned integer [2:3] - The length of the tag (8 + the length of the URL) [3:4] - Zeroed [4:8] - The offset as a little-endian encoded unsigned integer. [8:] - The URL to be included (up to 248 bytes long) OFFSET is the offset into the content where the mention appears. URL is the URL to be inserted at the offset. This is a URL to a web page.","title":"Content Segment: URL"},{"location":"core_tags/#content-segment-image","text":"0x25 0 2 3 4 8 0x0 +-------------------------------+ 0 | 0x25 |LEN |0x0| OFFSET | 0x8 +-------------------------------+ 8 | URL... | +-------------------------------+ [0:2] - The type 0x25 as a little-endian encoded unsigned integer [2:3] - The length of the tag (8 + the length of the URL) [3:4] - Zeroed [4:8] - The offset as a little-endian encoded unsigned integer. [8:] - The URL to be included (up to 248 bytes long) OFFSET is the offset into the content where the mention appears. URL is the URL to be inserted at the offset. This is a URL to an image","title":"Content Segment: Image"},{"location":"core_tags/#content-segment-video","text":"0x26 0 2 3 4 8 0x0 +-------------------------------+ 0 | 0x26 |LEN |0x0| OFFSET | 0x8 +-------------------------------+ 8 | URL... | +-------------------------------+ [0:2] - The type 0x26 as a little-endian encoded unsigned integer [2:3] - The length of the tag (8 + the length of the URL) [3:4] - Zeroed [4:8] - The offset as a little-endian encoded unsigned integer. [8:] - The URL to be included (up to 248 bytes long) OFFSET is the offset into the content where the mention appears. URL is the URL to be inserted at the offset. This is a URL to a video","title":"Content Segment: Video"},{"location":"cryptography/","text":"Cryptography PAGE STATUS: early draft Hashing We use BLAKE3 in unkeyed hashing mode, producing a 512-bit digest, storing only the first 256-bits in the record but passing the full 512-bits into EdDSA Rationale: EdDSA ed25519 is defined to use SHA-512 and we are using BLAKE3 as a drop-in replacement, so we have to produce 512-bit hashes. But these do not need to be in the record. What the record needs is some way to index and reference it, and the 256 bit prefix is enough for that. In BLAKE3, hashes are variable size, and smaller outputs are prefixes of longer outputs. This is a very fast hash function with 128-bit security. It is even sometimes faster in software than hardware versions of SHA-256, and is about 14x as fast as software versions of SHA-256. It is highly parallelizable and can take advantage of vector instructions. It's predecessor BLAKE was the most analyzed algorithm during the NIST SHA-3 competition. Digital Signature We use EdDSA with the ed25519 curve and very specific public key and signature validation checks. In particular: Public keys should be rejected if they are one of 8 small order points. Signatures must be rejected if s is not within the range 0..L-1. Signatures must be rejected if R or A are non-canonical (e.g. verify that |R| >= L and |A| >= L) Always use cofactor verification (8(S \u00b7 B) \u2212 8R \u2212 8(h \u00b7 A) = 0) not the non-cofactor one, even when not in batch mode. Rationale: Fast and space efficient Widely studied Very good resistance to side-channel attacks Does not require point validation In our form, provides the following guarantees: Existentially and Strongly unforgeable under chosen message attacks Strongly Binding Signature Interoperates with TLS, Mainline DHT, and other modern ed25519-based identity systems See Taming the many EdDSAs See The Provable Security of Ed25519: Theory and Practice Encryption Records in Mosaic are generally not encrypted, but public things. However some applications have a need to encrypt data. This is a general specification of how encryption is done. Encryption details are still TBD but we intend: To use ECIES To do the diffie-hellman between an ephemeral keypair generated by the sender and used only once, and one of the recipient's x25519 public keys (published in their key schedule), which is not ephemeral but may nonetheless be frequently rolled over by the recipient. In order for a user to decrypt on any of their devices, they must share the x25519 public key's secret to all of their devices. In order to preserve signing security, these keys are separate from ed25519 signing keys. See keyschedule marker 0x2. See also this page at cryptosys.net","title":"Cryptography"},{"location":"cryptography/#cryptography","text":"PAGE STATUS: early draft","title":"Cryptography"},{"location":"cryptography/#hashing","text":"We use BLAKE3 in unkeyed hashing mode, producing a 512-bit digest, storing only the first 256-bits in the record but passing the full 512-bits into EdDSA Rationale: EdDSA ed25519 is defined to use SHA-512 and we are using BLAKE3 as a drop-in replacement, so we have to produce 512-bit hashes. But these do not need to be in the record. What the record needs is some way to index and reference it, and the 256 bit prefix is enough for that. In BLAKE3, hashes are variable size, and smaller outputs are prefixes of longer outputs. This is a very fast hash function with 128-bit security. It is even sometimes faster in software than hardware versions of SHA-256, and is about 14x as fast as software versions of SHA-256. It is highly parallelizable and can take advantage of vector instructions. It's predecessor BLAKE was the most analyzed algorithm during the NIST SHA-3 competition.","title":"Hashing"},{"location":"cryptography/#digital-signature","text":"We use EdDSA with the ed25519 curve and very specific public key and signature validation checks. In particular: Public keys should be rejected if they are one of 8 small order points. Signatures must be rejected if s is not within the range 0..L-1. Signatures must be rejected if R or A are non-canonical (e.g. verify that |R| >= L and |A| >= L) Always use cofactor verification (8(S \u00b7 B) \u2212 8R \u2212 8(h \u00b7 A) = 0) not the non-cofactor one, even when not in batch mode. Rationale: Fast and space efficient Widely studied Very good resistance to side-channel attacks Does not require point validation In our form, provides the following guarantees: Existentially and Strongly unforgeable under chosen message attacks Strongly Binding Signature Interoperates with TLS, Mainline DHT, and other modern ed25519-based identity systems See Taming the many EdDSAs See The Provable Security of Ed25519: Theory and Practice","title":"Digital Signature"},{"location":"cryptography/#encryption","text":"Records in Mosaic are generally not encrypted, but public things. However some applications have a need to encrypt data. This is a general specification of how encryption is done. Encryption details are still TBD but we intend: To use ECIES To do the diffie-hellman between an ephemeral keypair generated by the sender and used only once, and one of the recipient's x25519 public keys (published in their key schedule), which is not ephemeral but may nonetheless be frequently rolled over by the recipient. In order for a user to decrypt on any of their devices, they must share the x25519 public key's secret to all of their devices. In order to preserve signing security, these keys are separate from ed25519 signing keys. See keyschedule marker 0x2. See also this page at cryptosys.net","title":"Encryption"},{"location":"filter/","text":"Filter PAGE STATUS: early draft A filter is a binary structure used within the Core Protocol . It is defined as a contiguous sequence of type-value pairs. Some types specify a count or length within their value. Each entry restricts the set of records that the filter matches. Filter types MUST not be used more than once within a filter. Filters can be up to 65536 bytes long maximum, but this size may not be possible given other constraints. type name 0x1 Ids 0x2 Addresses 0x4 Author Keys 0x5 Signing Keys 0x6 Timestamps 0x7 Since 0x8 Until 0x9 Received Ats 0xA Received Since 0xB Received Until 0xC Kinds 0xD Tag Values 0xE Limit Ids 0x1 Matches all records that have any of these ids. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0x1| 0x0 | n | 8 +-------------------------------+ | Id 1/6 | 16 +-------------------------------+ | Id 2/6 | 24 +-------------------------------+ | Id 3/6 | 32 +-------------------------------+ | Id 4/6 | 40 +-------------------------------+ | Id 5/6 | 48 +-------------------------------+ | Id 6/6 | 56 +-------------------------------+ | ... additional ids.. | +-------------------------------+ The byte 0x1 Six bytes 0x0 A 1-byte count n , then A sequence of n 48-byte IDs. Addresses 0x2 Matches all records that have any of these addresses. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0x2| 0x0 | n | 8 +-------------------------------+ | ADDR 1/6 | 16 +-------------------------------+ | ADDR 2/6 | 24 +-------------------------------+ | ADDR 3/6 | 32 +-------------------------------+ | ADDR 4/6 | 32 +-------------------------------+ | ADDR 5/6 | 32 +-------------------------------+ | ADDR 6/6 | 40 +-------------------------------+ | ... additional addrs.. | +-------------------------------+ The byte 0x2 Six bytes 0x0 A 1-byte count n , then A sequence of n 48-byte addresses. Author Keys 0x4 Matches all records authored by any of these keys. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0x4| 0x0 | n | 8 +-------------------------------+ | AUTHOR KEY 1/4 | 16 +-------------------------------+ | AUTHOR KEY 2/4 | 24 +-------------------------------+ | AUTHOR KEY 3/4 | 32 +-------------------------------+ | AUTHOR KEY 4/4 | 40 +-------------------------------+ | ... additional keys.. | +-------------------------------+ The byte 0x4 Six bytes 0x0 A 1-byte count n , then A sequence of n 32-byte author public keys. Signing Keys 0x5 Matches all records signed by any of these keys. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0x5| 0x0 | n | 8 +-------------------------------+ | SIGNING KEY 1/4 | 16 +-------------------------------+ | SIGNING KEY 2/4 | 24 +-------------------------------+ | SIGNING KEY 3/4 | 32 +-------------------------------+ | SIGNING KEY 4/4 | 40 +-------------------------------+ | ... additional keys.. | +-------------------------------+ The byte 0x5 Six bytes 0x0 A 1-byte count n , then A sequence of n 32-byte signing public keys. Timestamps 0x6 Matches all records that have any of these exact timestamps. Typically used as part of address lookups. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0x6| 0x0 | n | 8 +-------------------------------+ | 0x0 | TIMESTAMP | 16 +-------------------------------+ | ..0x0 | ..TIMESTAMP | 24 +-------------------------------+ The byte 0x6 Six bytes 0x0 A 1-byte count n , then A sequence of n 8-byte fields, each being: Two bytes 0x0 A six byte timestamp . Since 0x7 Matches all records with a timestamp greater than or equal to this value. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0x7| 0x0 | 8 +-------------------------------+ | 0x0 | TIMESTAMP | 16 +-------------------------------+ The byte 0x7 Nine bytes 0x0 A 6-byte timestamp Until 0x8 Matches all records with a timestamp less than this value. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0x8| 0x0 | 8 +-------------------------------+ | 0x0 | TIMESTAMP | 16 +-------------------------------+ The byte 0x8 Nine bytes 0x0 A 6-byte timestamp Received Ats 0x9 Matches all records that were received at any of these exact timestamps. This is unlikely to be useful but we add it for completeness. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0x9| 0x0 | n | 8 +-------------------------------+ | 0x0 | TIMESTAMP | 16 +-------------------------------+ | ..0x0 | ..TIMESTAMP | 24 +-------------------------------+ The byte 0x9 Six bytes 0x0 A 1-byte count n , then A sequence of n 8-byte fields, each being: Two bytes 0x0 A six byte timestamp . Received Since 0xA Matches all records that were received by the server at or later than this value. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0xA| 0x0 | 8 +-------------------------------+ | 0x0 | TIMESTAMP | 16 +-------------------------------+ The byte 0xA Nine bytes 0x0 A 6-byte timestamp Received Until 0xB Matches all records that were received by the server before this value. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0xB| 0x0 | 8 +-------------------------------+ | 0x0 | TIMESTAMP | 16 +-------------------------------+ The byte 0xB Nine bytes 0x0 A 6-byte timestamp Kinds 0xC Matches all records which are of any one of these kinds. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0xC| 0x0 | n | 8 +-------------------------------+ | KIND | ...KIND | 16 +-------------------------------+ The byte 0xC 6 bytes 0x0 A 1-byte count n , then A sequence of n 4-byte kinds Tag Values 0xD Matches all records which have any one of these tag values for the tag type. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0xD|0x0| TTYPE | 0x0 | n | 8 +-------------------------------+ | DATA... | 16 +-------------------------------+ The byte 0xD 1 byte 0x0 A 2-byte tag type in little-endian format 3 bytes 0x0 A 1-byte count n , then DATA being a sequence of n length-value pairs (length being 1 byte) representing the n different values of the tag which cause the filter to match. This data is not aligned and tag values are of varying length. Limit 0xE Limits the records to the specified limit, providing only the most recent results. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0xE| 0x0 | LIMIT | 8 +-------------------------------+ The byte 0xE Three bytes 0x0 Four bytes representing a LIMIT, an unsigned integer in little-endian order.","title":"Filter"},{"location":"filter/#filter","text":"PAGE STATUS: early draft A filter is a binary structure used within the Core Protocol . It is defined as a contiguous sequence of type-value pairs. Some types specify a count or length within their value. Each entry restricts the set of records that the filter matches. Filter types MUST not be used more than once within a filter. Filters can be up to 65536 bytes long maximum, but this size may not be possible given other constraints. type name 0x1 Ids 0x2 Addresses 0x4 Author Keys 0x5 Signing Keys 0x6 Timestamps 0x7 Since 0x8 Until 0x9 Received Ats 0xA Received Since 0xB Received Until 0xC Kinds 0xD Tag Values 0xE Limit","title":"Filter"},{"location":"filter/#ids","text":"0x1 Matches all records that have any of these ids. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0x1| 0x0 | n | 8 +-------------------------------+ | Id 1/6 | 16 +-------------------------------+ | Id 2/6 | 24 +-------------------------------+ | Id 3/6 | 32 +-------------------------------+ | Id 4/6 | 40 +-------------------------------+ | Id 5/6 | 48 +-------------------------------+ | Id 6/6 | 56 +-------------------------------+ | ... additional ids.. | +-------------------------------+ The byte 0x1 Six bytes 0x0 A 1-byte count n , then A sequence of n 48-byte IDs.","title":"Ids"},{"location":"filter/#addresses","text":"0x2 Matches all records that have any of these addresses. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0x2| 0x0 | n | 8 +-------------------------------+ | ADDR 1/6 | 16 +-------------------------------+ | ADDR 2/6 | 24 +-------------------------------+ | ADDR 3/6 | 32 +-------------------------------+ | ADDR 4/6 | 32 +-------------------------------+ | ADDR 5/6 | 32 +-------------------------------+ | ADDR 6/6 | 40 +-------------------------------+ | ... additional addrs.. | +-------------------------------+ The byte 0x2 Six bytes 0x0 A 1-byte count n , then A sequence of n 48-byte addresses.","title":"Addresses"},{"location":"filter/#author-keys","text":"0x4 Matches all records authored by any of these keys. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0x4| 0x0 | n | 8 +-------------------------------+ | AUTHOR KEY 1/4 | 16 +-------------------------------+ | AUTHOR KEY 2/4 | 24 +-------------------------------+ | AUTHOR KEY 3/4 | 32 +-------------------------------+ | AUTHOR KEY 4/4 | 40 +-------------------------------+ | ... additional keys.. | +-------------------------------+ The byte 0x4 Six bytes 0x0 A 1-byte count n , then A sequence of n 32-byte author public keys.","title":"Author Keys"},{"location":"filter/#signing-keys","text":"0x5 Matches all records signed by any of these keys. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0x5| 0x0 | n | 8 +-------------------------------+ | SIGNING KEY 1/4 | 16 +-------------------------------+ | SIGNING KEY 2/4 | 24 +-------------------------------+ | SIGNING KEY 3/4 | 32 +-------------------------------+ | SIGNING KEY 4/4 | 40 +-------------------------------+ | ... additional keys.. | +-------------------------------+ The byte 0x5 Six bytes 0x0 A 1-byte count n , then A sequence of n 32-byte signing public keys.","title":"Signing Keys"},{"location":"filter/#timestamps","text":"0x6 Matches all records that have any of these exact timestamps. Typically used as part of address lookups. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0x6| 0x0 | n | 8 +-------------------------------+ | 0x0 | TIMESTAMP | 16 +-------------------------------+ | ..0x0 | ..TIMESTAMP | 24 +-------------------------------+ The byte 0x6 Six bytes 0x0 A 1-byte count n , then A sequence of n 8-byte fields, each being: Two bytes 0x0 A six byte timestamp .","title":"Timestamps"},{"location":"filter/#since","text":"0x7 Matches all records with a timestamp greater than or equal to this value. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0x7| 0x0 | 8 +-------------------------------+ | 0x0 | TIMESTAMP | 16 +-------------------------------+ The byte 0x7 Nine bytes 0x0 A 6-byte timestamp","title":"Since"},{"location":"filter/#until","text":"0x8 Matches all records with a timestamp less than this value. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0x8| 0x0 | 8 +-------------------------------+ | 0x0 | TIMESTAMP | 16 +-------------------------------+ The byte 0x8 Nine bytes 0x0 A 6-byte timestamp","title":"Until"},{"location":"filter/#received-ats","text":"0x9 Matches all records that were received at any of these exact timestamps. This is unlikely to be useful but we add it for completeness. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0x9| 0x0 | n | 8 +-------------------------------+ | 0x0 | TIMESTAMP | 16 +-------------------------------+ | ..0x0 | ..TIMESTAMP | 24 +-------------------------------+ The byte 0x9 Six bytes 0x0 A 1-byte count n , then A sequence of n 8-byte fields, each being: Two bytes 0x0 A six byte timestamp .","title":"Received Ats"},{"location":"filter/#received-since","text":"0xA Matches all records that were received by the server at or later than this value. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0xA| 0x0 | 8 +-------------------------------+ | 0x0 | TIMESTAMP | 16 +-------------------------------+ The byte 0xA Nine bytes 0x0 A 6-byte timestamp","title":"Received Since"},{"location":"filter/#received-until","text":"0xB Matches all records that were received by the server before this value. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0xB| 0x0 | 8 +-------------------------------+ | 0x0 | TIMESTAMP | 16 +-------------------------------+ The byte 0xB Nine bytes 0x0 A 6-byte timestamp","title":"Received Until"},{"location":"filter/#kinds","text":"0xC Matches all records which are of any one of these kinds. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0xC| 0x0 | n | 8 +-------------------------------+ | KIND | ...KIND | 16 +-------------------------------+ The byte 0xC 6 bytes 0x0 A 1-byte count n , then A sequence of n 4-byte kinds","title":"Kinds"},{"location":"filter/#tag-values","text":"0xD Matches all records which have any one of these tag values for the tag type. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0xD|0x0| TTYPE | 0x0 | n | 8 +-------------------------------+ | DATA... | 16 +-------------------------------+ The byte 0xD 1 byte 0x0 A 2-byte tag type in little-endian format 3 bytes 0x0 A 1-byte count n , then DATA being a sequence of n length-value pairs (length being 1 byte) representing the n different values of the tag which cause the filter to match. This data is not aligned and tag values are of varying length.","title":"Tag Values"},{"location":"filter/#limit","text":"0xE Limits the records to the specified limit, providing only the most recent results. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ |0xE| 0x0 | LIMIT | 8 +-------------------------------+ The byte 0xE Three bytes 0x0 Four bytes representing a LIMIT, an unsigned integer in little-endian order.","title":"Limit"},{"location":"human_encodings/","text":"Mosaic Human Encodings Human encodings are defined to provide uniform compatible ways for sharing data between humans and software. bech32 is used in many of these due to its superior properties. Refer to the link. Keys User public keys are encoded with bech32 using the moupub prefix. Server public keys are encoded with bech32 using the mospub prefix. Public keys can be encoded with bech32 using the mopub prefix if the encoder does not know whether it represents a user or a server. Secret keys are encoded with bech32 using the mosec prefix. Ids are encoded with bech32 using the moid prefix. Addresses are encoded with bech32 using the moaddr prefix.","title":"Human Encodings"},{"location":"human_encodings/#mosaic-human-encodings","text":"Human encodings are defined to provide uniform compatible ways for sharing data between humans and software. bech32 is used in many of these due to its superior properties. Refer to the link.","title":"Mosaic Human Encodings"},{"location":"human_encodings/#keys","text":"User public keys are encoded with bech32 using the moupub prefix. Server public keys are encoded with bech32 using the mospub prefix. Public keys can be encoded with bech32 using the mopub prefix if the encoder does not know whether it represents a user or a server. Secret keys are encoded with bech32 using the mosec prefix. Ids are encoded with bech32 using the moid prefix. Addresses are encoded with bech32 using the moaddr prefix.","title":"Keys"},{"location":"human_readable_content/","text":"Human Readable Content Records kinds which contain payloads of human readable content work as follows. The payload MUST be a valid UTF-8 encoded string. Any part of the intended content that is meant to have machine-readable meaning must not be in the payload, but instead specified in a content segment tag, which indicates the kind of content, the character (not byte) offset into the payload where this content should be rendered, and the value of the content. Multiple kinds of content segment tags are defined including: Content Segment: User Mention for things like @user . Content Segment: Server Mention for mentioning a server. Content Segment: Quote by id for quoting other records. Content Segment: Quote by addr for quoting other records. Content Segment: URL for inserting a URL to a website. Content Segment: Image for inserting an image. Content Segment: Video for inserting a video.","title":"Human Readable Content"},{"location":"human_readable_content/#human-readable-content","text":"Records kinds which contain payloads of human readable content work as follows. The payload MUST be a valid UTF-8 encoded string. Any part of the intended content that is meant to have machine-readable meaning must not be in the payload, but instead specified in a content segment tag, which indicates the kind of content, the character (not byte) offset into the payload where this content should be rendered, and the value of the content. Multiple kinds of content segment tags are defined including: Content Segment: User Mention for things like @user . Content Segment: Server Mention for mentioning a server. Content Segment: Quote by id for quoting other records. Content Segment: Quote by addr for quoting other records. Content Segment: URL for inserting a URL to a website. Content Segment: Image for inserting an image. Content Segment: Video for inserting a video.","title":"Human Readable Content"},{"location":"identity/","text":"Identity PAGE STATUS: early draft Users and Servers Identities are split between Users and Servers. Users in Mosaic are self-created and self-administered. This puts each user in control of their own account, allowing them to digitally sign their content, move to different servers and not to rely on any central service or authority. This however also requires each end user to securely manage their private key material. Convenient methods for doing so, as well as recovery, are outside of the scope of Mosaic except insomuch as we define master keys and subkeys with the purpose that subkeys are intended for online use, and master keys are intended to be long-term and kept more securely, perhaps being offline, in hardware, or managed by a trusted service. Public key cryptosystem keypair Identities are realized as a keypair produced within a public key cryptosystem. We use the EdDSA ed25519 cryptosystem for digital signature. See cryptography . A user is identified by their ed25519 master public key. Master keys and Subkeys Users may have subsidiary public keys, known as subkeys . At times this may also be called signing keys or device keys . The purpose of subkeys is for online usage in less secure environments, where compromise and revocation do not invalidate the master key identity that the user is known by. Subkeys also support alternative algorithms, such as X25519 public keys for receiving encrypted information, or nostr secp256k1 keys for backwards compatibility with nostr. Users publish their subkeys in a key schedule record , defined within the core records specification. A limited number of low-frequency operations in Mosaic require a signature from the master key. These include (presently): Publishing/modifying a User Bootstrap listing their servers Publishing/modifying a user's Key Schedule with new keys and/or revocations. Publishing/modifying a user's Profile record. Subkeys might be deterministically derived from the master private key, or they might not. Nothing in the Mosaic spec requires such, but some implementations may make use of this.","title":"Identity"},{"location":"identity/#identity","text":"PAGE STATUS: early draft","title":"Identity"},{"location":"identity/#users-and-servers","text":"Identities are split between Users and Servers. Users in Mosaic are self-created and self-administered. This puts each user in control of their own account, allowing them to digitally sign their content, move to different servers and not to rely on any central service or authority. This however also requires each end user to securely manage their private key material. Convenient methods for doing so, as well as recovery, are outside of the scope of Mosaic except insomuch as we define master keys and subkeys with the purpose that subkeys are intended for online use, and master keys are intended to be long-term and kept more securely, perhaps being offline, in hardware, or managed by a trusted service.","title":"Users and Servers"},{"location":"identity/#public-key-cryptosystem-keypair","text":"Identities are realized as a keypair produced within a public key cryptosystem. We use the EdDSA ed25519 cryptosystem for digital signature. See cryptography . A user is identified by their ed25519 master public key.","title":"Public key cryptosystem keypair"},{"location":"identity/#master-keys-and-subkeys","text":"Users may have subsidiary public keys, known as subkeys . At times this may also be called signing keys or device keys . The purpose of subkeys is for online usage in less secure environments, where compromise and revocation do not invalidate the master key identity that the user is known by. Subkeys also support alternative algorithms, such as X25519 public keys for receiving encrypted information, or nostr secp256k1 keys for backwards compatibility with nostr. Users publish their subkeys in a key schedule record , defined within the core records specification. A limited number of low-frequency operations in Mosaic require a signature from the master key. These include (presently): Publishing/modifying a User Bootstrap listing their servers Publishing/modifying a user's Key Schedule with new keys and/or revocations. Publishing/modifying a user's Profile record. Subkeys might be deterministically derived from the master private key, or they might not. Nothing in the Mosaic spec requires such, but some implementations may make use of this.","title":"Master keys and Subkeys"},{"location":"keyschedule/","text":"Key Schedule Record PAGE STATUS: early draft A key schedule record lists subkey information and revocation information for a master key. A key schedule record has kind 0x1. A key schedule record MUST be considered invalid if it does not conform to this specification. A key schedule record MUST be considered invalid if the signing key and the master key are not identical. Tags Every subkey listed in a key schedule record must have an associated Subkey tag listing the subkey. Payload `The payload contains a sequence of 40-byte subkey records laid out as follows: 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ | SUBKEY 1/4 | 8 +-------------------------------+ | SUBKEY 2/4 | 16 +-------------------------------+ | SUBKEY 3/4 | 24 +-------------------------------+ | SUBKEY 4/4 | 32 +-------------------------------+ |MARKER|RES|REVOC TIMESTAMP | +-------------------------------+ [0:32] - SUBKEY is the 32-byte subkey [32:33] - MARKER is 1-byte and is one of the following 0x0 - ACTIVE_SIGNING_KEY - A Mosaic ed25519 signing key (subkey) in current use 0x1 - ACTIVE_ENCRYPTION_KEY - A Mosaic X25519 encryption key in current use These keys are used for receiving encrypted data only, not for signing. Generally the secretkey for encryption is distributed to every device that needs the ability to view encrypted data. Being a separate subkey from the signing keys, it limits the damage from compromise. 0x40 - REVOKED_ALL - All records signed by the key are to be considered invalid. 0x41 - REVOKED_PAST - Records signed by the key that were received prior to the revocation timestamp (based on when it was received by software and NOT based on the date inside of the record) are still considered valid; however, records either received after the revocation timestamp, or with a timestamp after the revocation timestamp, are considered invalid. 0x4F - OUT_OF_USE - Key is no longer in use (but nothing is revoked). This may be used for signing keys or encryption keys. 0x80 - ACTIVE_NOSTR_KEY - A nostr secp256k1 subkey This helps support dual-stack software that works with both nostr and Mosaic. [33:34] - RES is 1-byte and is reserved. It MUST be 0. [34:40] - REVOC TIMESTAMP is 6-bytes and is in the format described in timestamps . Timestamp is required for REVOKED ALL and REVOKED PAST. Timestamp is suggested for OUT_OF_USE. Timestamp SHOULD be zeroed in all other cases. Server Used These are posted to all of the author's Outbox servers.","title":"Key Schedule Record"},{"location":"keyschedule/#key-schedule-record","text":"PAGE STATUS: early draft A key schedule record lists subkey information and revocation information for a master key. A key schedule record has kind 0x1. A key schedule record MUST be considered invalid if it does not conform to this specification. A key schedule record MUST be considered invalid if the signing key and the master key are not identical.","title":"Key Schedule Record"},{"location":"keyschedule/#tags","text":"Every subkey listed in a key schedule record must have an associated Subkey tag listing the subkey.","title":"Tags"},{"location":"keyschedule/#payload","text":"`The payload contains a sequence of 40-byte subkey records laid out as follows: 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ | SUBKEY 1/4 | 8 +-------------------------------+ | SUBKEY 2/4 | 16 +-------------------------------+ | SUBKEY 3/4 | 24 +-------------------------------+ | SUBKEY 4/4 | 32 +-------------------------------+ |MARKER|RES|REVOC TIMESTAMP | +-------------------------------+ [0:32] - SUBKEY is the 32-byte subkey [32:33] - MARKER is 1-byte and is one of the following 0x0 - ACTIVE_SIGNING_KEY - A Mosaic ed25519 signing key (subkey) in current use 0x1 - ACTIVE_ENCRYPTION_KEY - A Mosaic X25519 encryption key in current use These keys are used for receiving encrypted data only, not for signing. Generally the secretkey for encryption is distributed to every device that needs the ability to view encrypted data. Being a separate subkey from the signing keys, it limits the damage from compromise. 0x40 - REVOKED_ALL - All records signed by the key are to be considered invalid. 0x41 - REVOKED_PAST - Records signed by the key that were received prior to the revocation timestamp (based on when it was received by software and NOT based on the date inside of the record) are still considered valid; however, records either received after the revocation timestamp, or with a timestamp after the revocation timestamp, are considered invalid. 0x4F - OUT_OF_USE - Key is no longer in use (but nothing is revoked). This may be used for signing keys or encryption keys. 0x80 - ACTIVE_NOSTR_KEY - A nostr secp256k1 subkey This helps support dual-stack software that works with both nostr and Mosaic. [33:34] - RES is 1-byte and is reserved. It MUST be 0. [34:40] - REVOC TIMESTAMP is 6-bytes and is in the format described in timestamps . Timestamp is required for REVOKED ALL and REVOKED PAST. Timestamp is suggested for OUT_OF_USE. Timestamp SHOULD be zeroed in all other cases.","title":"Payload"},{"location":"keyschedule/#server-used","text":"These are posted to all of the author's Outbox servers.","title":"Server Used"},{"location":"kinds/","text":"Record Kinds PAGE STATUS: Early Draft Kinds are 4-byte unsigned integers in little-endian format. This page is a Registry of kinds, their name, and the standard that defines them. Refer to their definitions in the standards that define them. Kind Name Standard Server Used 0x1 Key Schedule Mosaic Core Key Schedule Outbox 0x2 Profile Mosaic Core Profile Outbox 0x3 Microblog Root Mosaic Social Media Microblog Root Outbox 0x4 Reply Comment Mosaic Social Media Reply Comment Outbox & Parent Author Inbox 0x5 Blog Post Mosaic Social Media Blog Post Outbox 0x6 Chat Message Mosaic Social Media Chat Message Chat Server","title":"Record Kind Registry"},{"location":"kinds/#record-kinds","text":"PAGE STATUS: Early Draft Kinds are 4-byte unsigned integers in little-endian format. This page is a Registry of kinds, their name, and the standard that defines them. Refer to their definitions in the standards that define them. Kind Name Standard Server Used 0x1 Key Schedule Mosaic Core Key Schedule Outbox 0x2 Profile Mosaic Core Profile Outbox 0x3 Microblog Root Mosaic Social Media Microblog Root Outbox 0x4 Reply Comment Mosaic Social Media Reply Comment Outbox & Parent Author Inbox 0x5 Blog Post Mosaic Social Media Blog Post Outbox 0x6 Chat Message Mosaic Social Media Chat Message Chat Server","title":"Record Kinds"},{"location":"microblog/","text":"Microblog PAGE STATUS: incomplete Kind = 0x4 - Root Payload The payload follows the Human Readable Content rules. Flags 0x01 ZSTD - may be on or off 0x02 FROMAUTHOR - may be on or off to control distribution. 0x04 TORECIPIENTS - MUST be off. Microblogs are public. 0x08 NOBRIDGE - may be on or off 0x10 EPHEMERAL- MUST be off. Reply comments are not ephemeral. Server Used These are posted to all of the author's Outbox servers.","title":"Microblogging"},{"location":"microblog/#microblog","text":"PAGE STATUS: incomplete Kind = 0x4 - Root","title":"Microblog"},{"location":"microblog/#payload","text":"The payload follows the Human Readable Content rules.","title":"Payload"},{"location":"microblog/#flags","text":"0x01 ZSTD - may be on or off 0x02 FROMAUTHOR - may be on or off to control distribution. 0x04 TORECIPIENTS - MUST be off. Microblogs are public. 0x08 NOBRIDGE - may be on or off 0x10 EPHEMERAL- MUST be off. Reply comments are not ephemeral.","title":"Flags"},{"location":"microblog/#server-used","text":"These are posted to all of the author's Outbox servers.","title":"Server Used"},{"location":"profile/","text":"Profile Record PAGE STATUS: TBD A profile record contains user profile information. A profile record has kind 0x2. Server Used These are posted to all of the author's Outbox servers.","title":"Profile Record"},{"location":"profile/#profile-record","text":"PAGE STATUS: TBD A profile record contains user profile information. A profile record has kind 0x2.","title":"Profile Record"},{"location":"profile/#server-used","text":"These are posted to all of the author's Outbox servers.","title":"Server Used"},{"location":"protocol/","text":"Protocol PAGE STATUS: early draft Protocol message are not separately digitally signed due to the TLS transport and certificate authentication. Protocol Extensions Protocol extension negotiation is done on a transport-by-transport level. For WebSockets transport (the default) this is done with the X-Mosaic-Extensions header. The following extensions have been defined: Sync Protocol Extension Asynchronous All client messages initiate an action, and all server messages are in response to client messages (NOTE: this may not apply to Mosaic extensions). Yet messaging is asychronous and both sides SHOULD be prepared to deal with a message sent at any time. Servers SHOULD not send messages until they receive a message that requires a response. If a server fails to receive a message from a client that does not have an open query or submission within a reasonable timeframe, it MAY close the connection. If a client receives a server message that was not expected, it MUST ignore it and decide what to do next. In some cases, clients MAY close the connection because the service they were seeking failed. In other cases they MAY try something else. There is no provision for a client to alert a server of an error. Messages Every message starts with a one-byte type, shown below in the header of each type. Following this is the data of the message. Initiator Message Client Query Client Close Query Client Submission Server Record Server Query Complete Server Query Closed Server Submission Result Client messages Query 0x1 This is a query for records in the following format: 1 2 3 0 8 6 4 2 0 +-------------------------------+ | 0x1 | QUERY_ID | 0x0 | +-------------------------------+ | FILTER LEN | 0x0 | +-------------------------------+ | FILTER ... | | ... | +-------------------------------+ The QUERY_ID should be made up by the client. It can be any 16-bit number and is used for associating responses. FILTER_LEN is a 16-bit little-endian integer indicating the length of the filter. The FILTER is defined in filter . This is a client initiated message. Servers are expected to reply with: a series of zero or more Record messages representing all the matching records on the server initially, followed by a Query Complete message, potentially followed by zero or more Record messages that flow in to the server after the initial response (so long as the query is still open), or a Query Closed message if the query could not be served. Queries MUST return results in anti-chronological order, from most recent backwards. Close Query 0x2 This is a client request to close a query in the following format: 1 2 3 0 8 6 4 2 0 +-------------------------------+ | 0x2 | QUERY_ID | 0x0 | +-------------------------------+ This is a client initiated message. Servers are expected to reply with: Query Closed Submission 0x3 This is the submission of a record in the following format: 1 2 3 0 8 6 4 2 0 +-------------------------------+ | 0x3 | LENGTH | +-------------------------------+ | RECORD ... | | ... | +-------------------------------+ LENGTH is a 24-bit little-endian length, with a maximum value of the max length of a record (1024576 bytes) and representing the actual length of the subsequent record submitted. RECORD is the record. This is a client initiated message. Servers are expected to reply with: Submission Result with an id prefix matching the record. Server messages Record 0x80 This is a record returned from a query in the following format: 1 2 3 0 8 6 4 2 0 +-------------------------------+ | 0x80 | QUERY_ID | 0x0 | +-------------------------------+ | 0x0 | LENGTH | +-------------------------------+ | RECORD ... | | ... | +-------------------------------+ The QUERY_ID is the client query that this record matched. The LENGTH is the length of the record as a 24-bit little-endian encoded value. The RECORD is the actual record This is a server response message in response to Query . Query Complete 0x81 This is a message indicating that a query is complete, in the following format: 1 2 3 0 8 6 4 2 0 +-------------------------------+ | 0x81 | QUERY_ID | 0x0 | +-------------------------------+ This indicates that a query is complete. This does not mean the query will close, as subsequently received records that match the query will be subsequently returned. This is a server response message in response to Query . Query Closed 0x82 This is a message indicating that a query has been closed, in the following format: 1 2 3 0 8 6 4 2 0 +-------------------------------+ | 0x82 | QUERY_ID | CODE | +-------------------------------+ The QUERY_ID is the client query that is being closed that was previously supplied by the client in a Query . The CODE indicates the reason for closure, from among the following defined reasons. ON_REQUEST : 0x1 - In response to Close Query REJECTED_INVALID : 0x10 - Query was rejected due to being invalid REJECTED_TOO_OPEN : 0x11 - Query was rejected due to being too open (scraping too many records) REJECTED_TOO_FAST : 0x12 - Query was rejected due to too many queries (or messages of any type) being submitted recently by this client REJECTED_TEMP_BANNED : 0x13 - Query was rejected due to the client beint temporarily banned REJECTED_PERM_BANNED : 0x14 - Query was rejected due to the client beint permanently banned SHUTTING_DOWN : 0x30 - The server is shutting down INTERNAL_ERROR : 0xF0 - A server error occured OTHER : 0xFF - Some other reason Submission Result 0x83 This is a message returning the result of a Submission in the following format: 1 2 3 0 8 6 4 2 0 +-------------------------------+ | 0x83 | 0x0 | 0x0 | CODE | +-------------------------------+ | ID PREFIX 1/8 | +-------------------------------+ | ID PREFIX 2/8 | +-------------------------------+ | ID PREFIX 3/8 | +-------------------------------+ | ID PREFIX 4/8 | +-------------------------------+ | ID PREFIX 5/8 | +-------------------------------+ | ID PREFIX 6/8 | +-------------------------------+ | ID PREFIX 7/8 | +-------------------------------+ | ID PREFIX 8/8 | +-------------------------------+ The CODE indicates the result of the submission from among the following defined results: OK : 0x1 - Record submission was accepted DUPLICATE : 0x2 - Record is a duplicate. Servers may use this or they may optionally use OK in the same circumstance. REJECTED_INVALID : 0x10 - Record is invalid REJECTED_TOO_FAST : 0x12 - Record submission was rejected due to too many submissions (or messages of any type) being made recently by this client REJECTED_TEMP_BANNED : 0x13 - Record submission was rejected due to the client being temporarily banned REJECTED_PERM_BANNED : 0x14 - Record submission was rejected due to the client being permanently banned REJECTED_REQUIRES_AUTHN : 0x15 - Record submission requires authentication but the client is connected anonymously. REJECTED_REQUIRES_AUTHZ : 0x16 - Record submission requires authorization (e.g. an account with the server) which the client user does not have. INTERNAL_ERROR : 0xF0 - A server error occured OTHER : 0xFF - Some other reason FIXME: add proof of work (not defined yet) The ID_PREFIX is the first 32 bytes of the record id","title":"Core Protocol"},{"location":"protocol/#protocol","text":"PAGE STATUS: early draft Protocol message are not separately digitally signed due to the TLS transport and certificate authentication.","title":"Protocol"},{"location":"protocol/#protocol-extensions","text":"Protocol extension negotiation is done on a transport-by-transport level. For WebSockets transport (the default) this is done with the X-Mosaic-Extensions header. The following extensions have been defined: Sync Protocol Extension","title":"Protocol Extensions"},{"location":"protocol/#asynchronous","text":"All client messages initiate an action, and all server messages are in response to client messages (NOTE: this may not apply to Mosaic extensions). Yet messaging is asychronous and both sides SHOULD be prepared to deal with a message sent at any time. Servers SHOULD not send messages until they receive a message that requires a response. If a server fails to receive a message from a client that does not have an open query or submission within a reasonable timeframe, it MAY close the connection. If a client receives a server message that was not expected, it MUST ignore it and decide what to do next. In some cases, clients MAY close the connection because the service they were seeking failed. In other cases they MAY try something else. There is no provision for a client to alert a server of an error.","title":"Asynchronous"},{"location":"protocol/#messages","text":"Every message starts with a one-byte type, shown below in the header of each type. Following this is the data of the message. Initiator Message Client Query Client Close Query Client Submission Server Record Server Query Complete Server Query Closed Server Submission Result","title":"Messages"},{"location":"protocol/#client-messages","text":"","title":"Client messages"},{"location":"protocol/#query","text":"0x1 This is a query for records in the following format: 1 2 3 0 8 6 4 2 0 +-------------------------------+ | 0x1 | QUERY_ID | 0x0 | +-------------------------------+ | FILTER LEN | 0x0 | +-------------------------------+ | FILTER ... | | ... | +-------------------------------+ The QUERY_ID should be made up by the client. It can be any 16-bit number and is used for associating responses. FILTER_LEN is a 16-bit little-endian integer indicating the length of the filter. The FILTER is defined in filter . This is a client initiated message. Servers are expected to reply with: a series of zero or more Record messages representing all the matching records on the server initially, followed by a Query Complete message, potentially followed by zero or more Record messages that flow in to the server after the initial response (so long as the query is still open), or a Query Closed message if the query could not be served. Queries MUST return results in anti-chronological order, from most recent backwards.","title":"Query"},{"location":"protocol/#close-query","text":"0x2 This is a client request to close a query in the following format: 1 2 3 0 8 6 4 2 0 +-------------------------------+ | 0x2 | QUERY_ID | 0x0 | +-------------------------------+ This is a client initiated message. Servers are expected to reply with: Query Closed","title":"Close Query"},{"location":"protocol/#submission","text":"0x3 This is the submission of a record in the following format: 1 2 3 0 8 6 4 2 0 +-------------------------------+ | 0x3 | LENGTH | +-------------------------------+ | RECORD ... | | ... | +-------------------------------+ LENGTH is a 24-bit little-endian length, with a maximum value of the max length of a record (1024576 bytes) and representing the actual length of the subsequent record submitted. RECORD is the record. This is a client initiated message. Servers are expected to reply with: Submission Result with an id prefix matching the record.","title":"Submission"},{"location":"protocol/#server-messages","text":"","title":"Server messages"},{"location":"protocol/#record","text":"0x80 This is a record returned from a query in the following format: 1 2 3 0 8 6 4 2 0 +-------------------------------+ | 0x80 | QUERY_ID | 0x0 | +-------------------------------+ | 0x0 | LENGTH | +-------------------------------+ | RECORD ... | | ... | +-------------------------------+ The QUERY_ID is the client query that this record matched. The LENGTH is the length of the record as a 24-bit little-endian encoded value. The RECORD is the actual record This is a server response message in response to Query .","title":"Record"},{"location":"protocol/#query-complete","text":"0x81 This is a message indicating that a query is complete, in the following format: 1 2 3 0 8 6 4 2 0 +-------------------------------+ | 0x81 | QUERY_ID | 0x0 | +-------------------------------+ This indicates that a query is complete. This does not mean the query will close, as subsequently received records that match the query will be subsequently returned. This is a server response message in response to Query .","title":"Query Complete"},{"location":"protocol/#query-closed","text":"0x82 This is a message indicating that a query has been closed, in the following format: 1 2 3 0 8 6 4 2 0 +-------------------------------+ | 0x82 | QUERY_ID | CODE | +-------------------------------+ The QUERY_ID is the client query that is being closed that was previously supplied by the client in a Query . The CODE indicates the reason for closure, from among the following defined reasons. ON_REQUEST : 0x1 - In response to Close Query REJECTED_INVALID : 0x10 - Query was rejected due to being invalid REJECTED_TOO_OPEN : 0x11 - Query was rejected due to being too open (scraping too many records) REJECTED_TOO_FAST : 0x12 - Query was rejected due to too many queries (or messages of any type) being submitted recently by this client REJECTED_TEMP_BANNED : 0x13 - Query was rejected due to the client beint temporarily banned REJECTED_PERM_BANNED : 0x14 - Query was rejected due to the client beint permanently banned SHUTTING_DOWN : 0x30 - The server is shutting down INTERNAL_ERROR : 0xF0 - A server error occured OTHER : 0xFF - Some other reason","title":"Query Closed"},{"location":"protocol/#submission-result","text":"0x83 This is a message returning the result of a Submission in the following format: 1 2 3 0 8 6 4 2 0 +-------------------------------+ | 0x83 | 0x0 | 0x0 | CODE | +-------------------------------+ | ID PREFIX 1/8 | +-------------------------------+ | ID PREFIX 2/8 | +-------------------------------+ | ID PREFIX 3/8 | +-------------------------------+ | ID PREFIX 4/8 | +-------------------------------+ | ID PREFIX 5/8 | +-------------------------------+ | ID PREFIX 6/8 | +-------------------------------+ | ID PREFIX 7/8 | +-------------------------------+ | ID PREFIX 8/8 | +-------------------------------+ The CODE indicates the result of the submission from among the following defined results: OK : 0x1 - Record submission was accepted DUPLICATE : 0x2 - Record is a duplicate. Servers may use this or they may optionally use OK in the same circumstance. REJECTED_INVALID : 0x10 - Record is invalid REJECTED_TOO_FAST : 0x12 - Record submission was rejected due to too many submissions (or messages of any type) being made recently by this client REJECTED_TEMP_BANNED : 0x13 - Record submission was rejected due to the client being temporarily banned REJECTED_PERM_BANNED : 0x14 - Record submission was rejected due to the client being permanently banned REJECTED_REQUIRES_AUTHN : 0x15 - Record submission requires authentication but the client is connected anonymously. REJECTED_REQUIRES_AUTHZ : 0x16 - Record submission requires authorization (e.g. an account with the server) which the client user does not have. INTERNAL_ERROR : 0xF0 - A server error occured OTHER : 0xFF - Some other reason FIXME: add proof of work (not defined yet) The ID_PREFIX is the first 32 bytes of the record id","title":"Submission Result"},{"location":"record/","text":"Record PAGE STATUS: draft A record is a datum within Mosaic. All datums are records. Notation Byte slice notation [m:n] indicates the bytes including m up to and including the byte n-1 but not including the byte n . For example [8:12] represents bytes 8, 9, 10 and 11. Maximum Size The maximum size of a record is 1 mebibyte (1,048,576 bytes). This is specified so that length fields inside of records can be of a defined fixed number of bits and so that software can make reasonable decisions about buffer sizes. Layout Note that records are laid out in a way to provide 64-bit alignment. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ | Signature 1/8 | 8 +-------------------------------+ | Signature 2/8 | 16 +-------------------------------+ | Signature 3/8 | 24 +-------------------------------+ | Signature 4/8 | 32 +-------------------------------+ | Signature 5/8 | 40 +-------------------------------+ | Signature 6/8 | 48 +-------------------------------+ | Signature 7/8 | 56 +-------------------------------+ | Signature 8/8 | 64 +-------------------------------+ <-----| | BE Timestamp | Hash | 72 +-------------------------------+ | | Hash 2/6 | | 80 +-------------------------------+ | | Hash 3/6 | I | 88 +-------------------------------+ D | | Hash 4/6 | | 96 +-------------------------------+ | | Hash 5/6 | | 104 +-------------------------------+ | | Hash 6/6 | | 112 +-------------------------------+ <-----| | Signing public key, 1/4 | 120 +-------------------------------+ | Signing public key, 2/4 | 128 +-------------------------------+ | Signing public key, 3/4 | 136 +-------------------------------+ | Signing public key, 4/4 | 144 +-------------------------------+ <-----| | Orig BE Timestamp | Kind | | 152 +-------------------------------+ | | Nonce | A | 160 +-------------------------------+ D | | Author public key, 1/4 | D | 168 +-------------------------------+ R | | Author public key, 2/4 | E | 176 +-------------------------------+ S | | Author public key, 3/4 | S | 184 +-------------------------------+ | | Author public key, 4/4 | | 192 +-------------------------------+ <-----| | Flags | Timestamp | 200 +-------------------------------+ |AppFlgs| Len_t | Len_p | 208 +-------------------------------+ | Tags... | | .. +PADDING | ? +-------------------------------+ | Payload ... | | .. +PADDING | ? +-------------------------------+ Fields Records contain the following fields. See the layout section for the binary layout of these fields within a record. Signature 64 bytes at [0:64] The signature field is the EdDSA ed25519ph signature of the record produced using the construction procedure. Id 48 bytes at [64:112] This ID field is produced using the construction procedure. Signing Public Key 32 bytes at [112:144] This is the public key of the signing keypair, which is usually a subkey under the author's master keypair (but theoretically could be delegated in some other fashion in the future). This is represented in 32 bytes (256 bits). Orig BE Timestamp 6 bytes at [144:150] This is the original timestamp represented in 6 bytes (48 bits) according to timestamps , except in big-endian format. If the record is not a replacement of another record (the usual case) this is the same value as Timestamp . If the record is a replacement of another record, it copies the address from the original record which will fill this with the original record timestamp. Rationale: By putting the timestamp at the front of the address, addresses sort in time order and group temporally (for database performance). Kind 2 bytes at [150:152] This is the kind of the record which determines the application this record is part of, which then determines the nature of the non-core tags and the payload. This is represented in 2 bytes (16 bits) as an unsigned integer, little-endian. Nonce 8 bytes at [152:160] which are randomly generated by the author. This keeps addresses unique. Author Public Key 32 bytes at [160:192] This is the identity of the author, expressed as a public key from their master EdDSA ed25519 keypair, which is represented in 32 bytes (256 bits). Flags 2 bytes at [192:194] 0x01 ZSTD - The payload is compressed with Zstd 0x02 FROM_AUTHOR - Servers SHOULD only accept the record from the author (requiring authentication) 0x04 TO_RECIPIENTS - Servers SHOULD only serve the record to people tagged (requiring authentication) 0x08 NO_BRIDGE - Bridges SHOULD NOT propogate the record to other networks (nostr, mastodon, etc) 0x10 EPHEMERAL - The record is ephemeral; Servers should serve it to current subscribers and not keep it. 0x20 - RESERVED and MUST be 0 0x80, 0x40 - Signature scheme: 00 - (default) EdDSA ed25519 01 - (nostr) secp256k1 Schnorr 10 - RESERVED 11 - RESERVED NOTE: This only affects the signing key and the signature. The hash is always created with BLAKE3, and the master key is always EdDSA ed25519. This enables using nostr keys as subkeys. All other bits - RESERVED and MUST be 0 Timestamp 6 bytes at [194:200] This is a timestamp represented in 6 bytes (48 bits) according to timestamps . If this record replaces a previous record, this timestamp MUST be larger than Orig Timestamp . Rationale: It might seem like we have too many timestamps. But we need a timestamp of the current record, separate from the address, and which gets hashed by the hashing algorithm (the timestamp in the ID was not part of the hashing input). AppFlgs 2 bytes at [200:202] These are bitflags reserved for use by the specific application based on the kind . Len_t 2 bytes at [202:204] representing the length of the tags section in bytes as an unsigned integer in little-endian format. This represents the exact length of the tags section, not counting padding at the end to achieve 64-bit alignment. The maximum tags section length is 65536 bytes. Len_p 4 bytes at [204:208] representing the length of the payload section in bytes as an unsigned integer in little-endian format. This represents the exact length of the payload section, not counting padding at the end to achieve 64-bit alignment. The maximum payload section length is 1_048_384 bytes. Tags Varying bytes at [208:208+Len_t] These are searchable key-value tags. Unlike nostr tags, all of these are searchable. If an application requires unsearchable tags, these can be defined within that application's payload. Tags are laid out as follows: 0 2 3 256 max +-----------+---------+----------+ | type | length | value ...| +-----------+---------+----------+ Each tag has a 2-byte (16 bit) type [0:2] , a 1-byte (8 bit) length [2:3] , and a value that is at most 253 bytes long [3:] . Tags only have one value. The tags section is padded out to 64-bit alignment. The maximum tags section length is 65536 bytes. Tag types are documented at Tag Type Registry and the tags are defined at Core Tags . Rationale: Tag values should not be too large as they need to be indexed by relays. Constraining the value to 253 bytes allows an entire TLV (with 16-bit type and 8-bit length) to fit within 256 bytes. Payload Varying bytes at [208+Len_t:208+Len_t+Len_p]. Payload is opaque (at this layer of specification) application-specific data. The payload section is padded out to 64-bit alignment. The maximum payload section length is 1_048_384 bytes Construction Fill in all the data from [112:] . Take a BLAKE3 hash of [112:] , unkeyed, and extend to 64 bytes of output using BLAKE3's finalize_xof() function. This does not directly go into the record. Generate EdDSA ed25519ph pre-hashed signature of that 512-bit hash using the Signing private key, and providing the context string of \"Mosaic\". NOTE: ed25519 calls for a SHA-512 hash, but we use a BLAKE3 hash instead. Place the signature at bytes [0:64] . Copy the first 48 bytes of the hash to [64:112] . Write the timestamp as a 48-bit unsigned big-endian overtop of the first 6 bytes of the hash [64:70] . Rationale: EdDSA specifies SHA-512, but BLAKE3 is faster especially for longer messages, and EdDSA works just fine with it. We provide a context so that users cannot be tricked by one application into signing content for a different application (in case users think they can use the same keypair for every application). In order for IDs to sort in time order, and to group temporally (for database performance) we start them with the timestamp. We want the ID to have at least 32 bytes of hash, and with the timestamp overwrite part we extended it. This makes IDs 48-bytes long, which conveniently matches the length of addrs. Validation Records MUST be fully validated by clients. Records MUST be fully validated by servers except for the steps marked CLIENTS ONLY. Validation steps The length must be between 208 and 1048576 bytes. The length must equal 208 + Len_t + Len_p. The Signing public key must be validated according to the cryptography key validation checks. The Author public key must be validated according to the cryptography key validation checks. CLIENTS ONLY: The Signing public key must be verified to be a non-revoked subkey of the Author via the Author's bootstrap . Take a BLAKE3 hash of [112:] , unkeyed, and extend to 64 bytes of output using BLAKE3's finalize_xof() function. Verify the hash: Compare bytes [6:48] of this hash with bytes [70:112] of the record. They MUST match. Verify the ID timestamp: bytes [64:70] taken as a big-endian 48-bit unsigned integer must equal bytes [194:200] taken as a little-endian unsigned 48-bit integer. Verify the signature: The signature must be a valid EdDSA ed25519 signature of the hash taken in step 6 with the signing public key. The timestamp and the orig timestamp must be validated according to timestamps . All reserved flags must be set to 0. CLIENTS ONLY: Application specific validation should be performed.","title":"Record Format"},{"location":"record/#record","text":"PAGE STATUS: draft A record is a datum within Mosaic. All datums are records.","title":"Record"},{"location":"record/#notation","text":"Byte slice notation [m:n] indicates the bytes including m up to and including the byte n-1 but not including the byte n . For example [8:12] represents bytes 8, 9, 10 and 11.","title":"Notation"},{"location":"record/#maximum-size","text":"The maximum size of a record is 1 mebibyte (1,048,576 bytes). This is specified so that length fields inside of records can be of a defined fixed number of bits and so that software can make reasonable decisions about buffer sizes.","title":"Maximum Size"},{"location":"record/#layout","text":"Note that records are laid out in a way to provide 64-bit alignment. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ | Signature 1/8 | 8 +-------------------------------+ | Signature 2/8 | 16 +-------------------------------+ | Signature 3/8 | 24 +-------------------------------+ | Signature 4/8 | 32 +-------------------------------+ | Signature 5/8 | 40 +-------------------------------+ | Signature 6/8 | 48 +-------------------------------+ | Signature 7/8 | 56 +-------------------------------+ | Signature 8/8 | 64 +-------------------------------+ <-----| | BE Timestamp | Hash | 72 +-------------------------------+ | | Hash 2/6 | | 80 +-------------------------------+ | | Hash 3/6 | I | 88 +-------------------------------+ D | | Hash 4/6 | | 96 +-------------------------------+ | | Hash 5/6 | | 104 +-------------------------------+ | | Hash 6/6 | | 112 +-------------------------------+ <-----| | Signing public key, 1/4 | 120 +-------------------------------+ | Signing public key, 2/4 | 128 +-------------------------------+ | Signing public key, 3/4 | 136 +-------------------------------+ | Signing public key, 4/4 | 144 +-------------------------------+ <-----| | Orig BE Timestamp | Kind | | 152 +-------------------------------+ | | Nonce | A | 160 +-------------------------------+ D | | Author public key, 1/4 | D | 168 +-------------------------------+ R | | Author public key, 2/4 | E | 176 +-------------------------------+ S | | Author public key, 3/4 | S | 184 +-------------------------------+ | | Author public key, 4/4 | | 192 +-------------------------------+ <-----| | Flags | Timestamp | 200 +-------------------------------+ |AppFlgs| Len_t | Len_p | 208 +-------------------------------+ | Tags... | | .. +PADDING | ? +-------------------------------+ | Payload ... | | .. +PADDING | ? +-------------------------------+","title":"Layout"},{"location":"record/#fields","text":"Records contain the following fields. See the layout section for the binary layout of these fields within a record.","title":"Fields"},{"location":"record/#signature","text":"64 bytes at [0:64] The signature field is the EdDSA ed25519ph signature of the record produced using the construction procedure.","title":"Signature"},{"location":"record/#id","text":"48 bytes at [64:112] This ID field is produced using the construction procedure.","title":"Id"},{"location":"record/#signing-public-key","text":"32 bytes at [112:144] This is the public key of the signing keypair, which is usually a subkey under the author's master keypair (but theoretically could be delegated in some other fashion in the future). This is represented in 32 bytes (256 bits).","title":"Signing Public Key"},{"location":"record/#orig-be-timestamp","text":"6 bytes at [144:150] This is the original timestamp represented in 6 bytes (48 bits) according to timestamps , except in big-endian format. If the record is not a replacement of another record (the usual case) this is the same value as Timestamp . If the record is a replacement of another record, it copies the address from the original record which will fill this with the original record timestamp. Rationale: By putting the timestamp at the front of the address, addresses sort in time order and group temporally (for database performance).","title":"Orig BE Timestamp"},{"location":"record/#kind","text":"2 bytes at [150:152] This is the kind of the record which determines the application this record is part of, which then determines the nature of the non-core tags and the payload. This is represented in 2 bytes (16 bits) as an unsigned integer, little-endian.","title":"Kind"},{"location":"record/#nonce","text":"8 bytes at [152:160] which are randomly generated by the author. This keeps addresses unique.","title":"Nonce"},{"location":"record/#author-public-key","text":"32 bytes at [160:192] This is the identity of the author, expressed as a public key from their master EdDSA ed25519 keypair, which is represented in 32 bytes (256 bits).","title":"Author Public Key"},{"location":"record/#flags","text":"2 bytes at [192:194] 0x01 ZSTD - The payload is compressed with Zstd 0x02 FROM_AUTHOR - Servers SHOULD only accept the record from the author (requiring authentication) 0x04 TO_RECIPIENTS - Servers SHOULD only serve the record to people tagged (requiring authentication) 0x08 NO_BRIDGE - Bridges SHOULD NOT propogate the record to other networks (nostr, mastodon, etc) 0x10 EPHEMERAL - The record is ephemeral; Servers should serve it to current subscribers and not keep it. 0x20 - RESERVED and MUST be 0 0x80, 0x40 - Signature scheme: 00 - (default) EdDSA ed25519 01 - (nostr) secp256k1 Schnorr 10 - RESERVED 11 - RESERVED NOTE: This only affects the signing key and the signature. The hash is always created with BLAKE3, and the master key is always EdDSA ed25519. This enables using nostr keys as subkeys. All other bits - RESERVED and MUST be 0","title":"Flags"},{"location":"record/#timestamp","text":"6 bytes at [194:200] This is a timestamp represented in 6 bytes (48 bits) according to timestamps . If this record replaces a previous record, this timestamp MUST be larger than Orig Timestamp . Rationale: It might seem like we have too many timestamps. But we need a timestamp of the current record, separate from the address, and which gets hashed by the hashing algorithm (the timestamp in the ID was not part of the hashing input).","title":"Timestamp"},{"location":"record/#appflgs","text":"2 bytes at [200:202] These are bitflags reserved for use by the specific application based on the kind .","title":"AppFlgs"},{"location":"record/#len_t","text":"2 bytes at [202:204] representing the length of the tags section in bytes as an unsigned integer in little-endian format. This represents the exact length of the tags section, not counting padding at the end to achieve 64-bit alignment. The maximum tags section length is 65536 bytes.","title":"Len_t"},{"location":"record/#len_p","text":"4 bytes at [204:208] representing the length of the payload section in bytes as an unsigned integer in little-endian format. This represents the exact length of the payload section, not counting padding at the end to achieve 64-bit alignment. The maximum payload section length is 1_048_384 bytes.","title":"Len_p"},{"location":"record/#tags","text":"Varying bytes at [208:208+Len_t] These are searchable key-value tags. Unlike nostr tags, all of these are searchable. If an application requires unsearchable tags, these can be defined within that application's payload. Tags are laid out as follows: 0 2 3 256 max +-----------+---------+----------+ | type | length | value ...| +-----------+---------+----------+ Each tag has a 2-byte (16 bit) type [0:2] , a 1-byte (8 bit) length [2:3] , and a value that is at most 253 bytes long [3:] . Tags only have one value. The tags section is padded out to 64-bit alignment. The maximum tags section length is 65536 bytes. Tag types are documented at Tag Type Registry and the tags are defined at Core Tags . Rationale: Tag values should not be too large as they need to be indexed by relays. Constraining the value to 253 bytes allows an entire TLV (with 16-bit type and 8-bit length) to fit within 256 bytes.","title":"Tags"},{"location":"record/#payload","text":"Varying bytes at [208+Len_t:208+Len_t+Len_p]. Payload is opaque (at this layer of specification) application-specific data. The payload section is padded out to 64-bit alignment. The maximum payload section length is 1_048_384 bytes","title":"Payload"},{"location":"record/#construction","text":"Fill in all the data from [112:] . Take a BLAKE3 hash of [112:] , unkeyed, and extend to 64 bytes of output using BLAKE3's finalize_xof() function. This does not directly go into the record. Generate EdDSA ed25519ph pre-hashed signature of that 512-bit hash using the Signing private key, and providing the context string of \"Mosaic\". NOTE: ed25519 calls for a SHA-512 hash, but we use a BLAKE3 hash instead. Place the signature at bytes [0:64] . Copy the first 48 bytes of the hash to [64:112] . Write the timestamp as a 48-bit unsigned big-endian overtop of the first 6 bytes of the hash [64:70] . Rationale: EdDSA specifies SHA-512, but BLAKE3 is faster especially for longer messages, and EdDSA works just fine with it. We provide a context so that users cannot be tricked by one application into signing content for a different application (in case users think they can use the same keypair for every application). In order for IDs to sort in time order, and to group temporally (for database performance) we start them with the timestamp. We want the ID to have at least 32 bytes of hash, and with the timestamp overwrite part we extended it. This makes IDs 48-bytes long, which conveniently matches the length of addrs.","title":"Construction"},{"location":"record/#validation","text":"Records MUST be fully validated by clients. Records MUST be fully validated by servers except for the steps marked CLIENTS ONLY. Validation steps The length must be between 208 and 1048576 bytes. The length must equal 208 + Len_t + Len_p. The Signing public key must be validated according to the cryptography key validation checks. The Author public key must be validated according to the cryptography key validation checks. CLIENTS ONLY: The Signing public key must be verified to be a non-revoked subkey of the Author via the Author's bootstrap . Take a BLAKE3 hash of [112:] , unkeyed, and extend to 64 bytes of output using BLAKE3's finalize_xof() function. Verify the hash: Compare bytes [6:48] of this hash with bytes [70:112] of the record. They MUST match. Verify the ID timestamp: bytes [64:70] taken as a big-endian 48-bit unsigned integer must equal bytes [194:200] taken as a little-endian unsigned 48-bit integer. Verify the signature: The signature must be a valid EdDSA ed25519 signature of the hash taken in step 6 with the signing public key. The timestamp and the orig timestamp must be validated according to timestamps . All reserved flags must be set to 0. CLIENTS ONLY: Application specific validation should be performed.","title":"Validation"},{"location":"reference/","text":"References PAGE STATUS: early draft A reference is a pointer from one record to another. Mosaic defines two kinds of references Id Reference A id reference is a pointer to an exact record with no provision for replacement or edits. It contains some hash of the message making it unique. See record for the Id field. Address Reference An address reference is a pointer to a group of records that have the same address, which usually represent an initial record and it's subsequent replacements, often (and by default presumably) with the most recent record superceding the older records. An address consists of four fields which are contiguous and in order in the record layout at [128:176] making up 48 bytes. The original timestamp (6 bytes) in big-endian, The kind (2 bytes), The the author's public key (32 bytes), The random nonce (8 bytes), An author can replace a record by creating a new record with the same address, in which case the address is copied (the nonce is not randomly generated). Replaced records must then contain the same author key and be of the same kind. They may however be signed by a different signing keypair or have their flags modified, their tags changed, and their content changed. The timestamp of a replacement record MUST be larger than the original timestamp in the address. Rationale: By containing the Author public key, record location can be determined through bootstrapping . At only 48 bytes long, these can easily fit into a 253 byte tag when needed. By not including the hash of content, records can be edited and replaced by the author (where edits make sense) By containing the kind, records that are edited cannot change their kind. By containing the kind, software can filter records that are not relevant to a situation without needing to look them up first. By putting the timestamp at the front of the address, addresses sort in time order and group temporally (for database performance). By containing the original timestamp and a 64-bit nonce, it is statistically infeasible for two different records to have the same address unintentionally. In fact this is overkill, but using anything shorter that still aligns at 64-bits ends up being not unique enough.","title":"References"},{"location":"reference/#references","text":"PAGE STATUS: early draft A reference is a pointer from one record to another. Mosaic defines two kinds of references","title":"References"},{"location":"reference/#id-reference","text":"A id reference is a pointer to an exact record with no provision for replacement or edits. It contains some hash of the message making it unique. See record for the Id field.","title":"Id Reference"},{"location":"reference/#address-reference","text":"An address reference is a pointer to a group of records that have the same address, which usually represent an initial record and it's subsequent replacements, often (and by default presumably) with the most recent record superceding the older records. An address consists of four fields which are contiguous and in order in the record layout at [128:176] making up 48 bytes. The original timestamp (6 bytes) in big-endian, The kind (2 bytes), The the author's public key (32 bytes), The random nonce (8 bytes), An author can replace a record by creating a new record with the same address, in which case the address is copied (the nonce is not randomly generated). Replaced records must then contain the same author key and be of the same kind. They may however be signed by a different signing keypair or have their flags modified, their tags changed, and their content changed. The timestamp of a replacement record MUST be larger than the original timestamp in the address. Rationale: By containing the Author public key, record location can be determined through bootstrapping . At only 48 bytes long, these can easily fit into a 253 byte tag when needed. By not including the hash of content, records can be edited and replaced by the author (where edits make sense) By containing the kind, records that are edited cannot change their kind. By containing the kind, software can filter records that are not relevant to a situation without needing to look them up first. By putting the timestamp at the front of the address, addresses sort in time order and group temporally (for database performance). By containing the original timestamp and a 64-bit nonce, it is statistically infeasible for two different records to have the same address unintentionally. In fact this is overkill, but using anything shorter that still aligns at 64-bits ends up being not unique enough.","title":"Address Reference"},{"location":"reply_comment/","text":"Reply Comment PAGE STATUS: incomplete Kind = 0x5 - Reply Comment Payload The payload follows the Human Readable Content rules. Flags 0x01 ZSTD - may be on or off 0x02 FROMAUTHOR - may be on or off to control distribution. 0x04 TORECIPIENTS - may be on or off. 0x08 NOBRIDGE - may be on or off 0x10 EPHEMERAL- MUST be off. Reply comments are not ephemeral. Tags This MUST include exactly one reply tag, either 0x2 or 0x3. This MUST include exactly one root tag, either 0x2 or 0x3. Server Used These are posted to all of the author's Outbox servers and also to all of the parent Record author's Inbox servers.","title":"Reply Comment"},{"location":"reply_comment/#reply-comment","text":"PAGE STATUS: incomplete Kind = 0x5 - Reply Comment","title":"Reply Comment"},{"location":"reply_comment/#payload","text":"The payload follows the Human Readable Content rules.","title":"Payload"},{"location":"reply_comment/#flags","text":"0x01 ZSTD - may be on or off 0x02 FROMAUTHOR - may be on or off to control distribution. 0x04 TORECIPIENTS - may be on or off. 0x08 NOBRIDGE - may be on or off 0x10 EPHEMERAL- MUST be off. Reply comments are not ephemeral.","title":"Flags"},{"location":"reply_comment/#tags","text":"This MUST include exactly one reply tag, either 0x2 or 0x3. This MUST include exactly one root tag, either 0x2 or 0x3.","title":"Tags"},{"location":"reply_comment/#server-used","text":"These are posted to all of the author's Outbox servers and also to all of the parent Record author's Inbox servers.","title":"Server Used"},{"location":"status/","text":"Status and Development Page statuses Page statuses move between these states TBD Incomplete Early Draft Draft (ready for others to review and comment on) Approved xN (N people have approved) Implemented in core Implemented in core + xN (N implementations are known to exist) Superceded (some other page now supercedes this) Note that developers are encouraged to comment on and discuss pages in any status, they don't have to wait for draft status. Versions and Attribution Many people are expected to contribute to Mosaic and as a result there are various divergent viewpoints as to how Mosaic ought to be. As a result, we label this edition as the Steve Farroll edition. You will see this at the bottom of every page. Other Mosaic contributors can fork this and maintain their own editions. The community will eventually settle on something because people want to be compatible. Principles of Design The protocol must be simple enough for multiple implementations to be developed, but simplicity is not the only factor. The protocol must be functional enough to support a wide range of applications beyond just social media ones. The protocol should not impede high-performance high-throughput implementations. It is okay to do things multiple ways so long as there is one default that all developers implement, and the rest of the \"ways\" are optional. For example, we can have multiple transports (WebSockets, WebTransport, even REST) without all the developers needing to move beyond WebSockets, so long as every implementation implements the WebSockets transport. Code that isn't required by everybody should be defined outside of core as an extension, transport, or application, as these are all optional. Core Library This specification is being developed in parallel to a core library . The findings from development feed back into this specification.","title":"Status and Development"},{"location":"status/#status-and-development","text":"","title":"Status and Development"},{"location":"status/#page-statuses","text":"Page statuses move between these states TBD Incomplete Early Draft Draft (ready for others to review and comment on) Approved xN (N people have approved) Implemented in core Implemented in core + xN (N implementations are known to exist) Superceded (some other page now supercedes this) Note that developers are encouraged to comment on and discuss pages in any status, they don't have to wait for draft status.","title":"Page statuses"},{"location":"status/#versions-and-attribution","text":"Many people are expected to contribute to Mosaic and as a result there are various divergent viewpoints as to how Mosaic ought to be. As a result, we label this edition as the Steve Farroll edition. You will see this at the bottom of every page. Other Mosaic contributors can fork this and maintain their own editions. The community will eventually settle on something because people want to be compatible.","title":"Versions and Attribution"},{"location":"status/#principles-of-design","text":"The protocol must be simple enough for multiple implementations to be developed, but simplicity is not the only factor. The protocol must be functional enough to support a wide range of applications beyond just social media ones. The protocol should not impede high-performance high-throughput implementations. It is okay to do things multiple ways so long as there is one default that all developers implement, and the rest of the \"ways\" are optional. For example, we can have multiple transports (WebSockets, WebTransport, even REST) without all the developers needing to move beyond WebSockets, so long as every implementation implements the WebSockets transport. Code that isn't required by everybody should be defined outside of core as an extension, transport, or application, as these are all optional.","title":"Principles of Design"},{"location":"status/#core-library","text":"This specification is being developed in parallel to a core library . The findings from development feed back into this specification.","title":"Core Library"},{"location":"sync_protocol_extension/","text":"Mosaic Sync Protocol Extension PAGE STATUS: incomplete This extends the protocol with negentropy support. The following messages are added: Client messages Sync Init 0x10 This is the initialization of a negentropy sync of records Sync Data 0x11 This is a data packet within a negentropy sync of records Sync Close 0x12 This is the closing of a negentropy sync of records Server messages Sync Data 0x91 This is a data packet within a negentropy sync of records Sync Error 0x93 This is an indication that negentropy sync has failed","title":"Sync Protocol Extension"},{"location":"sync_protocol_extension/#mosaic-sync-protocol-extension","text":"PAGE STATUS: incomplete This extends the protocol with negentropy support. The following messages are added:","title":"Mosaic Sync Protocol Extension"},{"location":"sync_protocol_extension/#client-messages","text":"","title":"Client messages"},{"location":"sync_protocol_extension/#sync-init","text":"0x10 This is the initialization of a negentropy sync of records","title":"Sync Init"},{"location":"sync_protocol_extension/#sync-data","text":"0x11 This is a data packet within a negentropy sync of records","title":"Sync Data"},{"location":"sync_protocol_extension/#sync-close","text":"0x12 This is the closing of a negentropy sync of records","title":"Sync Close"},{"location":"sync_protocol_extension/#server-messages","text":"","title":"Server messages"},{"location":"sync_protocol_extension/#sync-data_1","text":"0x91 This is a data packet within a negentropy sync of records","title":"Sync Data"},{"location":"sync_protocol_extension/#sync-error","text":"0x93 This is an indication that negentropy sync has failed","title":"Sync Error"},{"location":"tag_types/","text":"Tag types PAGE STATUS: early draft Tag types are 2-byte (16-bit) unsigned integers in little-endian format. Each application registers their tag types here to prevent collision. Mosaic Core defines a few core tags in Core Tags . Tag Type Name Standard 0x1 Notify Public Key Mosaic Core Tags 0x2 Reply by Hash Mosaic Core Tags 0x3 Reply by Addr Mosaic Core Tags 0x4 Root by Hash Mosaic Core Tags 0x5 Root by Addr Mosaic Core Tags 0x20 Content Segment: User Mention Mosaic Core Tags 0x21 Content Segment: Server Mention Mosaic Core Tags 0x22 Content Segment: Quote by Id Mosaic Core Tags 0x23 Content Segment: Quote by Addr Mosaic Core Tags 0x24 Content Segment: URL Mosaic Core Tags 0x25 Content Segment: Image Mosaic Core Tags 0x26 Content Segment: Video Mosaic Core Tags Application defined tags are TBD.","title":"Tag Type Registry"},{"location":"tag_types/#tag-types","text":"PAGE STATUS: early draft Tag types are 2-byte (16-bit) unsigned integers in little-endian format. Each application registers their tag types here to prevent collision. Mosaic Core defines a few core tags in Core Tags . Tag Type Name Standard 0x1 Notify Public Key Mosaic Core Tags 0x2 Reply by Hash Mosaic Core Tags 0x3 Reply by Addr Mosaic Core Tags 0x4 Root by Hash Mosaic Core Tags 0x5 Root by Addr Mosaic Core Tags 0x20 Content Segment: User Mention Mosaic Core Tags 0x21 Content Segment: Server Mention Mosaic Core Tags 0x22 Content Segment: Quote by Id Mosaic Core Tags 0x23 Content Segment: Quote by Addr Mosaic Core Tags 0x24 Content Segment: URL Mosaic Core Tags 0x25 Content Segment: Image Mosaic Core Tags 0x26 Content Segment: Video Mosaic Core Tags Application defined tags are TBD.","title":"Tag types"},{"location":"timestamps/","text":"Timestamps PAGE STATUS: draft Timestamps are unixtimes, adjusted for leap seconds, expressed in milliseconds, and encoded into a 48-bit unsigned integer in little-endian format. The first bit is 0. Records that have a 1 bit here SHOULD be ignored. The next 47 bits represent the number of milliseconds that have actually elapsed on the surface of the Earth since the UNIX epoch. The epoch is defined as (these definitions are believed to be equivalent): 1 January 1970 UTC Unixtime 0 NTP timestamp 2208988800 Julian Date 2440587.5 UT1 Julian Date 2440587.5004766666 TT NOTE: the fracton above beyond .5 represents the 9 seconds that UTC was behind TAI, plus the 32.184 seconds that TAI is behind TT. Timestamps account for all leap seconds, unlike unixtime and unlike NTP timestamps (both of which pretend that leap seconds did not happen). Before 1 Jan 1972, timestamps match unixtime. As of this writing (unixtime 1732829887) the current timetstamp which includes 28 additional leap seconds is 1732829915. Since computers tend to be synchronized with UTC for the time being, your software will need to be aware of leap seconds so it can adjust. Leap second data is available at the IANA leap second list The data should be interpreted as follows: The leftmost column is an NTP timestamp. Subtract 2_208_988_800 from it to get a unixtime. The rightmost column is an adjustment to TAI. Subtract 9 from it to get the number of leapseconds that have elapsed as of the time in the first column and thereafter (until the next entry). A timestamp is the current unixtime, plus the number of leap seconds that have elapsed. Rationale: UTC is a discontinous time scale that is occasionally adjusted by leap seconds. Unixtime is derived from UTC and is thus also discontinuous. Subtracting two unixtimes could give a time interval that is off by up to 28 seconds (for example when comparing dates before 1 Jan 1972 with today). The first bit is zero in case it is ever interpreted as a sign bit, in order to preserve sorting. Millisecond unixtimes in 47 bits give us more than 4000 years before they roll over. Refer to the IANA leap second list","title":"Timestamps"},{"location":"timestamps/#timestamps","text":"PAGE STATUS: draft Timestamps are unixtimes, adjusted for leap seconds, expressed in milliseconds, and encoded into a 48-bit unsigned integer in little-endian format. The first bit is 0. Records that have a 1 bit here SHOULD be ignored. The next 47 bits represent the number of milliseconds that have actually elapsed on the surface of the Earth since the UNIX epoch. The epoch is defined as (these definitions are believed to be equivalent): 1 January 1970 UTC Unixtime 0 NTP timestamp 2208988800 Julian Date 2440587.5 UT1 Julian Date 2440587.5004766666 TT NOTE: the fracton above beyond .5 represents the 9 seconds that UTC was behind TAI, plus the 32.184 seconds that TAI is behind TT. Timestamps account for all leap seconds, unlike unixtime and unlike NTP timestamps (both of which pretend that leap seconds did not happen). Before 1 Jan 1972, timestamps match unixtime. As of this writing (unixtime 1732829887) the current timetstamp which includes 28 additional leap seconds is 1732829915. Since computers tend to be synchronized with UTC for the time being, your software will need to be aware of leap seconds so it can adjust. Leap second data is available at the IANA leap second list The data should be interpreted as follows: The leftmost column is an NTP timestamp. Subtract 2_208_988_800 from it to get a unixtime. The rightmost column is an adjustment to TAI. Subtract 9 from it to get the number of leapseconds that have elapsed as of the time in the first column and thereafter (until the next entry). A timestamp is the current unixtime, plus the number of leap seconds that have elapsed. Rationale: UTC is a discontinous time scale that is occasionally adjusted by leap seconds. Unixtime is derived from UTC and is thus also discontinuous. Subtracting two unixtimes could give a time interval that is off by up to 28 seconds (for example when comparing dates before 1 Jan 1972 with today). The first bit is zero in case it is ever interpreted as a sign bit, in order to preserve sorting. Millisecond unixtimes in 47 bits give us more than 4000 years before they roll over. Refer to the IANA leap second list","title":"Timestamps"},{"location":"websockets/","text":"Mosaic over Websockets PAGE STATUS: Draft TLS Over WebSockets, Mosaic must use TLS version at least 1.2, preferably TLS 1.3 . TLS should specify the EdDSA signature algorithm, using the ed25519 signing keys. TLS certificates shall be either RawPublicKey or self-signed, and use the ed25519 public key (either the server's master public key or the client's signing public key). Servers SHOULD request client-side certificates if they wish to authenticate users. If clients do not provide certificates, they should be considered anonymous. Servers MAY present different services depending on whether a user is authenticated or not. WebSockets Mosaic messages are transported over WebSockets Sec-WebSocket-Protocol Clients must present the Sec-WebSocket-Protocol header field in the handshake with WebSocket with the value mosaic2024 . If this is not presented, a server may either refuse service and close the connection, or presume the connection is nostr (if it is dual-stack). It should not presume the connection is Mosaic. Servers MUST reply with the protocol they have accepted in the same header, at this point being only 'mosaic2024'. This subprotocol is not (as of this writing) registered with IANA, but does not conflict with registered subprotocols. X-Mosaic-Extensions Clients MAY present an X-Mosiac-Extensions header to specify the extentions they support and may wish to use. The value of an X-Mosiac-Extensions header is a list of extension names separated by semicolons. Clients SHOULD NOT present an X-Mosaic-Extensions header in the handshake unless they are not requesting any extensions. The following extension names are defined: SYNC Servers MUST check for an X-Mosaic-Extensions header. If one is specified, split it's contents on semicolons. Remove all extensions you are unable to service. Join these back together and return an X-Mosaic-Extensions header with this string. If that string was empty, use a - instead. Clients MUST check for an X-Mosaic-Extensions header during negotiation, and configure themselves to use only the extensions that the server returned to them, considering - as the empty set. X-Mosaic-Service-Url Servers MAY present a service URL for a website which users can visit in order to manage their relationship with the server (e.g. sign up for an account, make payment, view logs, or anything else that is relevant to that relationship). These kinds of activities are not standardized here. Binary All messages use websockets binary. Messages are formed as the binary message protocol specified in protocol . Each message starts with a single byte indicating the type, followed by the data that such type requires. Clients MUST only send client messages. If a server reads a server message from a client, it SHOULD disconnect. Servers MUST only send server messages. If a client reads a client message from a server, it SHOULD disconnect.","title":"WebSockets"},{"location":"websockets/#mosaic-over-websockets","text":"PAGE STATUS: Draft","title":"Mosaic over Websockets"},{"location":"websockets/#tls","text":"Over WebSockets, Mosaic must use TLS version at least 1.2, preferably TLS 1.3 . TLS should specify the EdDSA signature algorithm, using the ed25519 signing keys. TLS certificates shall be either RawPublicKey or self-signed, and use the ed25519 public key (either the server's master public key or the client's signing public key). Servers SHOULD request client-side certificates if they wish to authenticate users. If clients do not provide certificates, they should be considered anonymous. Servers MAY present different services depending on whether a user is authenticated or not.","title":"TLS"},{"location":"websockets/#websockets","text":"Mosaic messages are transported over WebSockets","title":"WebSockets"},{"location":"websockets/#sec-websocket-protocol","text":"Clients must present the Sec-WebSocket-Protocol header field in the handshake with WebSocket with the value mosaic2024 . If this is not presented, a server may either refuse service and close the connection, or presume the connection is nostr (if it is dual-stack). It should not presume the connection is Mosaic. Servers MUST reply with the protocol they have accepted in the same header, at this point being only 'mosaic2024'. This subprotocol is not (as of this writing) registered with IANA, but does not conflict with registered subprotocols.","title":"Sec-WebSocket-Protocol"},{"location":"websockets/#x-mosaic-extensions","text":"Clients MAY present an X-Mosiac-Extensions header to specify the extentions they support and may wish to use. The value of an X-Mosiac-Extensions header is a list of extension names separated by semicolons. Clients SHOULD NOT present an X-Mosaic-Extensions header in the handshake unless they are not requesting any extensions. The following extension names are defined: SYNC Servers MUST check for an X-Mosaic-Extensions header. If one is specified, split it's contents on semicolons. Remove all extensions you are unable to service. Join these back together and return an X-Mosaic-Extensions header with this string. If that string was empty, use a - instead. Clients MUST check for an X-Mosaic-Extensions header during negotiation, and configure themselves to use only the extensions that the server returned to them, considering - as the empty set.","title":"X-Mosaic-Extensions"},{"location":"websockets/#x-mosaic-service-url","text":"Servers MAY present a service URL for a website which users can visit in order to manage their relationship with the server (e.g. sign up for an account, make payment, view logs, or anything else that is relevant to that relationship). These kinds of activities are not standardized here.","title":"X-Mosaic-Service-Url"},{"location":"websockets/#binary","text":"All messages use websockets binary. Messages are formed as the binary message protocol specified in protocol . Each message starts with a single byte indicating the type, followed by the data that such type requires. Clients MUST only send client messages. If a server reads a server message from a client, it SHOULD disconnect. Servers MUST only send server messages. If a client reads a client message from a server, it SHOULD disconnect.","title":"Binary"},{"location":"webtransport/","text":"Mosaic over Webtransport PAGE STATUS: TBD Intend to specify a subprotocol in the websockets HTTP header","title":"WebTransport"},{"location":"webtransport/#mosaic-over-webtransport","text":"PAGE STATUS: TBD Intend to specify a subprotocol in the websockets HTTP header","title":"Mosaic over Webtransport"}]}